<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.19"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EleFits: Optimization and good practices</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="elefits_notext.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EleFits
   &#160;<span id="projectnumber">4.0.1</span>
   </div>
   <div id="projectbrief">A modern C++ API on top of CFitsIO</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.19 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Optimization and good practices<div class="ingroups"><a class="el" href="group__guidelines.html">Development guidelines</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<p>How to make a program efficient? </p>
<h1><a class="anchor" id="optim-intro"></a>
Foreword</h1>
<p>The implementation of EleFits focuses firstly on memory management, secondly on user-friendlyness and finally on performance. Much of its complexity is imputable to performance choices, like the heavy use of tuples which are not that fun to manipulates. On user side, few operations would be very detrimental to performance. Yet, a few would be, and there are thus a few things to know if one wants to get the most out of EleFits. Although it's not possible to statically sort the following items w.r.t. performance gain, we've tried to sort by orders of magnitude for classical use cases.</p>
<h1><a class="anchor" id="optim-data-copy"></a>
Avoid copies and implicit transforms</h1>
<p>This one is not specific to the <a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write Fits file contents.">Fits</a> format or EleFits at all, but is probably worth remembering when using a code devoted to dataset manipulation.</p>
<p>In the frame of the library usage, avoiding such operations boils down to:</p>
<ul>
<li>Relying on move semantics;</li>
<li>Avoiding casting;</li>
<li>Avoiding "scaling".</li>
</ul>
<p>Move semantics is a C++ feature you can look for on the Internet; Let us focus on the two other items.</p>
<p>When casting is explicit, let's assume that you know what to do. The case we'll describe in more details is implicit casting made internally by CFitsIO.</p>
<p>The <a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write Fits file contents.">Fits</a> format is obviously specified in terms of actual bytes, and therefore fixed-size types (e.g. 16- or 32-bit integers). CFitsIO mixes such fixed-size types with C types (e.g. <code>TLONG</code> maps to <code>long</code> while <code>LONG_IMG</code> maps to 32-bit integer), without providing to the user any straightforwad way of avoiding casting.</p>
<p>EleFits abstracts from this and provides a templated API, which internally handles fixed-size types and C types transparently to enforce consistency and limit the number of casts. Yet, only fixed-size types guarantee that there is no time spent in casting operation. It is therefore recommended to use fixed-size integers as the template parameters (e.g. <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int16_t</a></code>).</p>
<p>Scaling is an affine transform specified in the <a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write Fits file contents.">Fits</a> files as a pair of offset and scale parameters. The transform is applied at read-time by CFitsIO (and therefore EleFits), and at write-time when the type is not natively supported by <a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write Fits file contents.">Fits</a>. For example, <a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write Fits file contents.">Fits</a> does not support unsigned 16-bit integer values, but CFitsIO (and EleFits) does. To this end, it offsets the value to be written, writes it, and writes the offset parameter. This obviously has a non-negligible cost when applied to many values, like for table columns. In order to avoid scaling, users should stick to native <a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write Fits file contents.">Fits</a> types (e.g. <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int16_t</a></code> but not <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::uint16_t</a></code>).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__types.html" title="Which types to use?">On types</a></dd></dl>
<h1><a class="anchor" id="optim-hdu-jumping"></a>
Avoid jumping from one HDU to another</h1>
<p><a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write Fits file contents.">Fits</a> files are made of consecutive HDUs, themeselves made of an ASCII header unit followed by a binary data unit. Reading or writing data to or from an HDU consists in:</p>
<ul>
<li>Finding the HDU (more on that later) and accessing it;</li>
<li>Spotting the target location inside the ASCII or binary unit;</li>
<li>Reading or writing bits.</li>
</ul>
<p>In order to limit as much as possible the time spent in the first two operations, it is recommended to exploit each HDU as much as possible before moving to another one, to follow the HDU ordering, and to group operations in the header and then in the data unit. For example, read all the records you need to read from an HDU at once, or write all the columns you need to write in a table at once.</p>
<p>Ultimate optimization when creating an HDU is to complete the header unit first before writing the data unit:</p>
<ul>
<li>Rely on the initialization services (as opposed to the assignment services);</li>
<li>Write all of the additional records;</li>
<li>Write the data unit at once.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Initialize the header unit (write some standard records)</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;ext = f.initImageHdu&lt;float, 3&gt;(<a class="code" href="namespaceEuclid_1_1Cfitsio_1_1FileAccess.html#ace028f35c207bf1efa113c9e13273b98">name</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Write user records</span></div>
<div class="line">ext.header().writeSeq(record1, record2, record3);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Write data unit</span></div>
<div class="line">ext.raster().write(data);</div>
</div><!-- fragment --><p>For very large files, following the in-file HDU ordering can also make a difference.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__primer.html" title="The structure and contents of a Fits file, and how they relate to EleFits.">What's a Fits file?</a> </dd>
<dd>
<a class="el" href="group__iterators.html" title="Tools to iterate over HDUs with selected categories and/or states.">HDU selectors and iterators</a></dd></dl>
<h1><a class="anchor" id="optim-hdu-as-parameters"></a>
Use HDU handlers as function parameters</h1>
<p>EleFits is providing HDU handlers as light objects designed to be passed by reference. The other options are to specify the HDU index or name instead of passing the handler itself. This is subobtimal because:</p><ul>
<li>Each time you access an HDU by index, its position in the file is searched for;</li>
<li>Each time you access an HDU by name, header units are sequentially visited, and <code>EXTNAME</code> keyword is searched for, until its value matches the name.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Good :)</span></div>
<div class="line"><span class="keywordtype">void</span> doSomethingWithHdu(<span class="keyword">const</span> Hdu&amp; hdu);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Bad :(</span></div>
<div class="line"><span class="keywordtype">void</span> doSomethingWithHdu(<span class="keywordtype">long</span> index);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Very bad ;(</span></div>
<div class="line"><span class="keywordtype">void</span> doSomethingWithHdu(<span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&amp; name);</div>
</div><!-- fragment --><h1><a class="anchor" id="optim-multiple-read-write"></a>
Read and write multiple values at once</h1>
<p>EleFits provides services to read and write bunches of data through one single call. The reason is to skip steps (like bunny hopping in the file) and lower runtime and memory footprint.</p>
<p>This is especially true for binary table writing. Without diving into the implementation details, let's give a brief overview of what's happening in CFitsIO. <a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write Fits file contents.">Fits</a> tables are stored row-wise. When reading a single column, CFitsIO has to load each of the rows. When reaching the last value of the target column, CFitsIO has finally loaded the whole set of columns!</p>
<p>EleFits's multi-column reading and writing functions internally take advantage of a CFitsIO buffer to avoid passing through the data unit several times.</p>
<div class="fragment"><div class="line"><span class="comment">// Good :)</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;ext = f.access&lt;BintableHdu&gt;(index);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> columns = ext.columns().readSeq(</div>
<div class="line">    Named&lt;std::string&gt;(<span class="stringliteral">&quot;A&quot;</span>),</div>
<div class="line">    Named&lt;float&gt;(<span class="stringliteral">&quot;B&quot;</span>),</div>
<div class="line">    Named&lt;std::int16_t&gt;(<span class="stringliteral">&quot;C&quot;</span>)); <span class="comment">// Reads the whole data unit once</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Bad :(</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;ext = f.access&lt;BintableHdu&gt;(index);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> columnA = ext.columns().read&lt;<a class="codeRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&gt;(<span class="stringliteral">&quot;A&quot;</span>); <span class="comment">// Reads the whole data unit</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> columnB = ext.columns().read&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;B&quot;</span>); <span class="comment">// Reads the whole data unit again!</span></div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> columnC = ext.columns().read&lt;<a class="codeRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int16_t</a>&gt;(<span class="stringliteral">&quot;C&quot;</span>); <span class="comment">// Reads the whole data unit again and again...</span></div>
</div><!-- fragment --><p>The strategy holds for record IOs too, yet with smaller improvements to be expected.</p>
<div class="fragment"><div class="line"><span class="comment">// Good :)</span></div>
<div class="line"><span class="keyword">auto</span> records = hdu.header().parse(Named&lt;int&gt;(<span class="stringliteral">&quot;INT&quot;</span>), Named&lt;float&gt;(<span class="stringliteral">&quot;FLOAT&quot;</span>));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Bad :(</span></div>
<div class="line"><span class="keyword">auto</span> record1 = hdu.header().parse&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;INT&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> record2 = hdu.header().parse&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;FLOAT&quot;</span>);</div>
</div><!-- fragment --><h1><a class="anchor" id="optim-vector-column-trick"></a>
Don't use the CFitsIO vector column trick</h1>
<p>In order to lower the impact of reading table data colomn-wise, CFitsIO documentation recommends writing vector columns even for scalar concepts. That is, if scalar columns of 10,000 rows should be written, rather write 10,000 value-wide vector columns over one row. This indeed allows storing the column values contiguously, and therefore speeds up the accesses.</p>
<p>We think software optimization should not obfuscate the data, and the trick should be avoided as much as possible. Aforementioned multi-column reading and writing services of EleFits have no counterpart in CFitsIO, which makes the trick more relevant to CFitsIO users than to EleFits users.</p>
<p>To go further, CFitsIO "iterator" mechanism is the way to go for performance; it is a clean solution which keeps the data in the logical format. It has no counterpart in EleFits. For now... </p>
</div><!-- contents -->
<div class="ttc" id="abasic_string_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a></div><div class="ttdoc">STL class.</div></div>
<div class="ttc" id="anamespaceEuclid_1_1Cfitsio_1_1FileAccess_html_ace028f35c207bf1efa113c9e13273b98"><div class="ttname"><a href="namespaceEuclid_1_1Cfitsio_1_1FileAccess.html#ace028f35c207bf1efa113c9e13273b98">Euclid::Cfitsio::FileAccess::name</a></div><div class="ttdeci">std::string name(fitsfile *fptr)</div><div class="ttdoc">Get the file name.</div></div>
<div class="ttc" id="ainteger_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/types/integer.html">std::int16_t</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.19
</small></address>
</body>
</html>
