namespace Euclid {
namespace FitsIO {

/**

\defgroup iterators 3. HDU selectors and iterators
\brief Tools to iterate over HDUs with selected categories and/or states.


\section iterators-all Iterate over all HDUs of a MefFile


An iterator class and begin/end functions are defined to enable loops over all the HDUs of a MefFile.
Usage is straightforward:

\code
MefFile f(filename, MefFile::Permission::Edit);
// ...
for (const auto& hdu : f) {
    processHdu(hdu); // Do something with each HDU
}
\endcode


\section iterators-categories HDU categories and filters


HDUs can be selected using one of two dedicated classes: HduCategory or HduFilter.

An HduCategory object positions flags like: Primary or extension HDU, image or binary table HDU...
HDU categories can be composed with binary operators `&` (and), `|` (or) and `~` (not).
For example, to get the list of image extensions with integer values:

\code
const auto category = HduCategory::IntImage & HduCategory::Ext;
\endcode

An HduFilter is a list of acceptable HDU categories and unacceptable HDU categories.
They are buit with operators `+` (accept) and `-` (reject).
For example, to accept all real-valued images and Primary, excluding the HDUs which were just created:

\code
const auto filter = HduCategory::IntImage + HduCategory::Primary - HduCategory::Created;
\endcode

It is possible to check if an HDU is of given category or matches a given filter with method RecordHdu::matches, as follows:

\code
for (const auto& hdu : f) {
  if (hdu.matches(HduCategory::Primary)) {
    processPrimary(hdu);
  } else if (hdu.matches(HduCategory::Image)) {
    processImageExt(hdu.as<ImageHdu>());
  } else if (hdu.matches(HduCategory::Bintable)) {
    processBintableExt(hdu.as<BintableHdu>());
  }
}
\endcode


\section iterators-slected Iterate over selected HDUs of a MefFile


Similarly to the range loop presented at the beginning of this page, it is possible to loop over a subset of the HDUs of a MefFile.
This is done by creating the adequate iterator using method MefFile::select():

\code
for (const auto& hdu : f.select<ImageHdu>(HduCategory::Image & HduCategory::Created)) {
  processNewImage(hdu);
}
\endcode

The template parameter specifies the class to be returned: RecordHdu, ImageHdu, or BintableHdu.
It is used to constrain the given filter:
for ImageHdu (resp. BintableHdu), HduCategory::Image (resp. HduCategory::Bintable) is added to the filter.
Therefore, `f.select<ImageHdu>()` is strictly equivalent to `f.select<ImageHdu>(HduCategory::Image)`,
and the above example can be rewritten more straightforwardly:

\code
for (const auto& hdu : f.select<ImageHdu>(HduCategory::Created)) { // Don't repeat Image
  processNewImage(hdu);
}
\endcode

\warning
Even when using filters, the whole MefFile is scanned.
It is therefore very inefficient to write several loops when one would be enough.
For example, instead of:
\code
for (const auto& hdu : f.select<ImageHdu>()) { // Scans all HDUs
  processImage(hdu);
}
for (const auto& hdu : f.select<BintableHdu>()) { // Scans all HDUs again
  processBintable(hdu);
}
\endcode
write:
\code
for (const auto& hdu : f) {
  if (hdu.matches(HduCategory::Image)) {
    processImage(hdu.as<ImageHdu>());
  } else {
    processBintable(hdu.as<BintableHdu>());
  }
}
\endcode

*/

}
}
