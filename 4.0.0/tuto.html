<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.19"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EleFits: Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="elefits_notext.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EleFits
   &#160;<span id="projectnumber">4.0.0</span>
   </div>
   <div id="projectbrief">A modern C++ API on top of CFitsIO</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.19 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tuto-intro">Introduction</a></li>
<li class="level1"><a href="#tuto-setup">Setup</a></li>
<li class="level1"><a href="#tuto-data-classes">Data classes</a><ul><li class="level2"><a href="#tuto-record">Record</a></li>
<li class="level2"><a href="#tuto-raster">Raster</a></li>
<li class="level2"><a href="#tuto-column">Column</a></li>
</ul>
</li>
<li class="level1"><a href="#tuto-file">Open (and close) a MEF file</a></li>
<li class="level1"><a href="#tuto-write">Write a MEF file</a><ul><li class="level2"><a href="#tuto-write-ext">Create extensions</a></li>
<li class="level2"><a href="#tuto-write-record">Write records</a></li>
<li class="level2"><a href="#tuto-write-image">Write image data</a></li>
<li class="level2"><a href="#tuto-write-bintable">Write binary table data</a></li>
</ul>
</li>
<li class="level1"><a href="#tuto-read">Read a MEF file</a><ul><li class="level2"><a href="#tuto-access-hdu">Access HDUs</a></li>
<li class="level2"><a href="#tuto-read-record">Parse records</a></li>
<li class="level2"><a href="#tuto-read-image">Read image data</a></li>
<li class="level2"><a href="#tuto-read-bintable">Read binary table data</a></li>
</ul>
</li>
<li class="level1"><a href="#tuto-conclusion">Wrap up</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="tuto-intro"></a>
Introduction</h1>
<p>In this tutorial, we will show how to read and write multi-extension <a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write Fits file contents.">Fits</a> (MEF) files. This means understanding the usage of the following service classes:</p>
<ul>
<li><code><a class="el" href="classEuclid_1_1Fits_1_1MefFile.html" title="Multi-Extension Fits file reader-writer.">MefFile</a></code> at file level,</li>
<li><code><a class="el" href="classEuclid_1_1Fits_1_1ImageHdu.html" title="Image HDU reader-writer.">ImageHdu</a></code> and <code><a class="el" href="classEuclid_1_1Fits_1_1BintableHdu.html" title="Binary table HDU reader-writer.">BintableHdu</a></code> at HDU level,</li>
<li><code><a class="el" href="classEuclid_1_1Fits_1_1ImageRaster.html" title="Reader-writer for the image data unit.">ImageRaster</a></code> and <code><a class="el" href="classEuclid_1_1Fits_1_1BintableColumns.html" title="Column-wise reader-writer for the binary table data unit.">BintableColumns</a></code> at data unit level;</li>
</ul>
<p>as well as <code><a class="el" href="structEuclid_1_1Fits_1_1Record.html" title="Keyword-value pair with optional unit and comment.">Record</a></code>, <code><a class="el" href="classEuclid_1_1Fits_1_1Raster.html" title="Raster of a n-dimensional image (2D by default).">Raster</a></code> and <code><a class="el" href="classEuclid_1_1Fits_1_1Column.html" title="Binary table column data and metadata.">Column</a></code> data classes.</p>
<p>We strongly recommend reading first <a class="el" href="group__primer.html">What's a Fits file?</a>, even if you're familiar with the <a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write Fits file contents.">Fits</a> format, because it introduces <code>EleFits</code>-specific wording.</p>
<p>At the end of the tutorial, you will be able to create a MEF file from scratch with unlimited number of various extensions, and to read the metadata and data back!</p>
<p>The tutorial is built together with an example program: <a class="el" href="EleFitsTutorial_8cpp-example.html">EleFitsTutorial.cpp</a>. We've embedded the calls to the logger in the code snippets below, so that you can easily map the execution log to the following explanations. You can already run the program and watch the resulting file:</p>
<div class="fragment"><div class="line">EleFitsTutorial --output tuto.fits</div>
<div class="line">fv tuto.fits</div>
</div><!-- fragment --><p>We'll first discover the data classes, then use them to create a MEF file, and finally read the file and values back.</p>
<dl class="section see"><dt>See also</dt><dd>To go further, at the end of each section, a link points to the reference page for the introduced topic.</dd></dl>
<h1><a class="anchor" id="tuto-setup"></a>
Setup</h1>
<p>First things first, we have to declare the dependency to EleFits and to use the right headers and namespaces. For the first part, head to the <a class="el" href="install_guide.html">Installation and configuration guide</a>. For the headers and namespace, here's the only thing you'll have to do:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;EleFits/MefFile.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceEuclid.html">Euclid</a>;</div>
<div class="line"><span class="comment">// EleFits API is in the Euclid::Fits namespace.</span></div>
<div class="line"><span class="comment">// We could have be using namespace Euclid::Fits instead,</span></div>
<div class="line"><span class="comment">// but things would have been less obvious in the snippets.</span></div>
</div><!-- fragment --><h1><a class="anchor" id="tuto-data-classes"></a>
Data classes</h1>
<p>Data classes are the classes which hold the pieces of data read from and written to a <a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write Fits file contents.">Fits</a> file. There are three main classes:</p>
<ul>
<li><code><a class="el" href="structEuclid_1_1Fits_1_1Record.html" title="Keyword-value pair with optional unit and comment.">Record</a></code> for header units,</li>
<li><code><a class="el" href="classEuclid_1_1Fits_1_1Raster.html" title="Raster of a n-dimensional image (2D by default).">Raster</a></code> for data units of image HDUs,</li>
<li><code><a class="el" href="classEuclid_1_1Fits_1_1Column.html" title="Binary table column data and metadata.">Column</a></code> for data units of binary table HDUs.</li>
</ul>
<h2><a class="anchor" id="tuto-record"></a>
Record</h2>
<p>A keyword record as defined in the <a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write Fits file contents.">Fits</a> standard is a triplet of keyword, value and optional comment rendered in the file as: </p><div class="fragment"><div class="line">KEYWORD = VALUE / comment</div>
</div><!-- fragment --><p>A unit can be included in the comment as follows: </p><div class="fragment"><div class="line">KEYWORD = VALUE / [unit] comment</div>
</div><!-- fragment --><p>The value can be a Boolean, an integer, real or complex number, or a string.</p>
<p><code><a class="el" href="structEuclid_1_1Fits_1_1Record.html" title="Keyword-value pair with optional unit and comment.">Record</a></code> is a simple template class which merely stores those fields. For the purpose of the tutorial, we define a structure to hold our records:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>TutoRecords {</div>
<div class="line">  Fits::Record&lt;std::string&gt; stringRecord;</div>
<div class="line">  Fits::Record&lt;int&gt; intRecord;</div>
<div class="line">  Fits::Record&lt;float&gt; floatRecord;</div>
<div class="line">  Fits::Record&lt;std::complex&lt;double&gt;&gt; complexRecord;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Here's a how they can be built:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">/* Create a record with unit and comment */</span></div>
<div class="line"> </div>
<div class="line">  Fits::Record&lt;std::string&gt; stringRecord(<span class="stringliteral">&quot;STRING&quot;</span>, <span class="stringliteral">&quot;VALUE&quot;</span>, <span class="stringliteral">&quot;unit&quot;</span>, <span class="stringliteral">&quot;comment&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Create a record with keyword and value only */</span></div>
<div class="line"> </div>
<div class="line">  Fits::Record&lt;int&gt; intRecord(<span class="stringliteral">&quot;INT&quot;</span>, 0);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Create a record from an initialization list */</span></div>
<div class="line"> </div>
<div class="line">  Fits::Record&lt;float&gt; floatRecord { <span class="stringliteral">&quot;FLOAT&quot;</span>, 3.14F, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;A piece of Pi&quot;</span> };</div>
<div class="line">  <span class="comment">// This is often used as a shortcut to create records as function parameters.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Generate a random record */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> complexRecord = Fits::Test::generateRandomRecord&lt;std::complex&lt;double&gt;&gt;(<span class="stringliteral">&quot;COMPLEX&quot;</span>);</div>
<div class="line"> </div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__header__data__classes.html">Header data classes</a></dd></dl>
<h2><a class="anchor" id="tuto-raster"></a>
Raster</h2>
<p>Images in <a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write Fits file contents.">Fits</a> are <em>n</em>-dimensional arrays. <code><a class="el" href="classEuclid_1_1Fits_1_1Raster.html" title="Raster of a n-dimensional image (2D by default).">Raster</a></code> is a class which represents this kind of data and provides constant time pixel accessors. Template arguments are the pixel type and number of axes. There are two kinds of rasters:</p>
<ul>
<li><code><a class="el" href="classEuclid_1_1Fits_1_1VecRaster.html" title="Copy constructor.">VecRaster</a></code> owns the data as an <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html" title="STL class.">std::vector</a></code>;</li>
<li><code><a class="el" href="classEuclid_1_1Fits_1_1PtrRaster.html" title="Raster of a n-dimensional image (2D by default).">PtrRaster</a></code> points to the data owned by another class, as a raw pointer (be careful not to destroy the data while the raster is alive).</li>
</ul>
<p>The rasters of this tutorial are stored in a dedicated structure:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>TutoRasters {</div>
<div class="line">  Fits::VecRaster&lt;std::int16_t, 2&gt; int16Raster2D;</div>
<div class="line">  Fits::VecRaster&lt;std::int32_t, 3&gt; int32Raster3D;</div>
<div class="line">  Fits::VecRaster&lt;std::int64_t, 4&gt; int64Raster4D;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Again, let's show an example of how to create rasters:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">/* Initialize and later fill a raster */</span></div>
<div class="line"> </div>
<div class="line">  Fits::VecRaster&lt;std::int16_t, 2&gt; int16Raster2D({ 4, 3 });</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; position : int16Raster2D.domain()) {</div>
<div class="line">    int16Raster2D[position] = position[0] + position[1];</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// This demonstrates the iteration over positions;</span></div>
<div class="line">  <span class="comment">// It is possible to use two nested loops instead.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Create a raster from a vector */</span></div>
<div class="line"> </div>
<div class="line">  <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;std::int32_t&gt;</a> int32Vec(16 * 9 * 3, 0);</div>
<div class="line">  <span class="comment">// ... do what you have to do with the vector, and then move it to the raster ...</span></div>
<div class="line">  Fits::VecRaster&lt;std::int32_t, 3&gt; int32Raster3D({ 16, 9, 3 }, <a class="codeRef" href="http://en.cppreference.com/w/cpp/utility/move.html">std::move</a>(int32Vec));</div>
<div class="line">  <span class="comment">// Instead of moving a vector, it&#39;s also possible to work with</span></div>
<div class="line">  <span class="comment">// a raw pointer with the PtrRaster class.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Generate a random raster */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> int64Raster4D = Fits::Test::RandomRaster&lt;std::int64_t, 4&gt;({ 17, 9, 3, 24 });</div>
<div class="line"> </div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__image__data__classes.html">Image data classes</a></dd></dl>
<h2><a class="anchor" id="tuto-column"></a>
Column</h2>
<p>A binary table is made of columns which can be either scalar (each cell contains a value) or vector (each cell contains several values). In the latter case, the number of values per cell is named repeat count.</p>
<p>For string columns, the repeat count must be greater than the longest string value.</p>
<p>A <code><a class="el" href="classEuclid_1_1Fits_1_1Column.html" title="Binary table column data and metadata.">Column</a></code> is a simple structure which holds the column name, repeat count (=1 for scalar columns, &gt;1 for vector columns), unit, and owns or references some data, respectively as a <code><a class="el" href="classEuclid_1_1Fits_1_1VecColumn.html" title="Column which stores internally the data.">VecColumn</a></code> or as a <code><a class="el" href="classEuclid_1_1Fits_1_1PtrColumn.html" title="Column which references some external pointer data.">PtrColumn</a></code>.</p>
<p>The following structure stores the tutorial columns:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>TutoColumns {</div>
<div class="line">  Fits::VecColumn&lt;std::string&gt; stringColumn;</div>
<div class="line">  Fits::VecColumn&lt;std::int32_t&gt; int32Column;</div>
<div class="line">  Fits::VecColumn&lt;float&gt; float32Column;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Here's a set of examples on how create them:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">/* Initialize and later fill a column */</span></div>
<div class="line"> </div>
<div class="line">  Fits::VecColumn&lt;std::string&gt; stringColumn({ <span class="stringliteral">&quot;STRING&quot;</span>, <span class="stringliteral">&quot;unit&quot;</span>, 3 }, 100);</div>
<div class="line">  <span class="comment">// String columns must be wide-enough to hold each character.</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; stringColumn.rowCount(); ++i) {</div>
<div class="line">    stringColumn(i) = <a class="codeRef" href="http://en.cppreference.com/w/cpp/string/basic_string/to_string.html">std::to_string</a>(i);</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// operator() takes two parameters: the row index, and repeat index (=0 by default)</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Create a column from a vector */</span></div>
<div class="line"> </div>
<div class="line">  <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;std::int32_t&gt;</a> int32Vec(100);</div>
<div class="line">  <span class="comment">// ... do what you have to do with the vector, and then move it to the column ...</span></div>
<div class="line">  Fits::VecColumn&lt;std::int32_t&gt; int32Column({ <span class="stringliteral">&quot;INT32&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, 1 }, <a class="codeRef" href="http://en.cppreference.com/w/cpp/utility/move.html">std::move</a>(int32Vec));</div>
<div class="line">  <span class="comment">// Analogously to rasters, columns can be managed with the lightweight PtrColumn classe.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Generate a random column */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> float32Column = Fits::Test::RandomVectorColumn&lt;float&gt;(8, 100);</div>
<div class="line"> </div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__bintable__data__classes.html">Binary table data classes</a></dd></dl>
<h1><a class="anchor" id="tuto-file"></a>
Open (and close) a MEF file</h1>
<p>Now that we have learned about the data classes, we can move to the service classes, or handlers. The first thing we can do is to create a new file.</p>
<p>The <code><a class="el" href="classEuclid_1_1Fits_1_1MefFile.html" title="Multi-Extension Fits file reader-writer.">MefFile</a></code> class represents multi-extension <a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write Fits file contents.">Fits</a> (MEF) files. It extends the <code><a class="el" href="classEuclid_1_1Fits_1_1FitsFile.html" title="Fits file reader-writer.">FitsFile</a></code> class, which is also the base class of <code><a class="el" href="classEuclid_1_1Fits_1_1SifFile.html" title="Single image Fits file handler.">SifFile</a></code> for single-image <a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write Fits file contents.">Fits</a> (SIF) files.</p>
<p>Creating (or opening) a file is simply done with the constructor of <code><a class="el" href="classEuclid_1_1Fits_1_1MefFile.html" title="Multi-Extension Fits file reader-writer.">MefFile</a></code> (or <code><a class="el" href="classEuclid_1_1Fits_1_1SifFile.html" title="Single image Fits file handler.">SifFile</a></code> for SIF files!):</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  Fits::MefFile f(filename, Fits::FileMode::Create);</div>
<div class="line"> </div>
</div><!-- fragment --><p> A newly created <a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write Fits file contents.">Fits</a> file consists in an empty Primary, which can then be accessed and modified, but is never created by hand.</p>
<p>The mode parameter controls the access rights on the file. For example, an existing file can be opened with read-only mode:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  Fits::MefFile f(filename, Fits::FileMode::Read);</div>
<div class="line"> </div>
</div><!-- fragment --><p> The file is closed when the destructor of <code><a class="el" href="classEuclid_1_1Fits_1_1MefFile.html" title="Multi-Extension Fits file reader-writer.">MefFile</a></code> is called (although a <code><a class="el" href="classEuclid_1_1Fits_1_1FitsFile_a2a375231b3f0191a26cc466b7d1ab0c0.html#a2a375231b3f0191a26cc466b7d1ab0c0" title="Close the file.">FitsFile::close()</a></code> method is provided for convenience).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__file__handlers.html">File handlers</a></dd></dl>
<h1><a class="anchor" id="tuto-write"></a>
Write a MEF file</h1>
<h2><a class="anchor" id="tuto-write-ext"></a>
Create extensions</h2>
<p><code><a class="el" href="classEuclid_1_1Fits_1_1MefFile.html" title="Multi-Extension Fits file reader-writer.">MefFile</a></code> provides services to create and access extensions. Conceptually, <code><a class="el" href="classEuclid_1_1Fits_1_1MefFile.html" title="Multi-Extension Fits file reader-writer.">MefFile</a></code> is a <code><a class="el" href="classEuclid_1_1Fits_1_1FitsFile.html" title="Fits file reader-writer.">FitsFile</a></code> with a vector of HDUs (in contrast, <code><a class="el" href="classEuclid_1_1Fits_1_1SifFile.html" title="Single image Fits file handler.">SifFile</a></code> is a <code><a class="el" href="classEuclid_1_1Fits_1_1FitsFile.html" title="Fits file reader-writer.">FitsFile</a></code> with a single HDU).</p>
<p>HDUs are represented by two classes:</p>
<ul>
<li><code><a class="el" href="classEuclid_1_1Fits_1_1ImageHdu.html" title="Image HDU reader-writer.">ImageHdu</a></code> to access image HDUs,</li>
<li><code><a class="el" href="classEuclid_1_1Fits_1_1BintableHdu.html" title="Binary table HDU reader-writer.">BintableHdu</a></code> to access binary table HDUs.</li>
</ul>
<p>Both derive from parent class <code><a class="el" href="classEuclid_1_1Fits_1_1Hdu.html" title="Base class for ImageHdu and BintableHdu.">Hdu</a></code>.</p>
<p>To sum up, a <code><a class="el" href="classEuclid_1_1Fits_1_1MefFile.html" title="Multi-Extension Fits file reader-writer.">MefFile</a></code> is a vector of <code><a class="el" href="classEuclid_1_1Fits_1_1Hdu.html" title="Base class for ImageHdu and BintableHdu.">Hdu</a></code>s, which can be a mix of <code><a class="el" href="classEuclid_1_1Fits_1_1ImageHdu.html" title="Image HDU reader-writer.">ImageHdu</a></code>s and <code><a class="el" href="classEuclid_1_1Fits_1_1BintableHdu.html" title="Binary table HDU reader-writer.">BintableHdu</a></code>s.</p>
<p>There are two kinds of services in <code><a class="el" href="classEuclid_1_1Fits_1_1MefFile.html" title="Multi-Extension Fits file reader-writer.">MefFile</a></code> for creating extensions: They can be either initialized with header only or assigned directly with data. Here's an example of creating image HDUs:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">/* Fill the header and data units */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; image1 = f.assignImageExt(<span class="stringliteral">&quot;IMAGE1&quot;</span>, rasters.int32Raster3D);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Fill the header only (for now) */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; image2 = f.initImageExt&lt;<a class="codeRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int16_t</a>&gt;(<span class="stringliteral">&quot;IMAGE2&quot;</span>, rasters.int16Raster2D.shape());</div>
<div class="line"> </div>
</div><!-- fragment --><p> And here's one of creating binary table HDUs:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">/* Fill the header and data units */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; table1 = f.assignBintableExt(<span class="stringliteral">&quot;TABLE1&quot;</span>, columns.stringColumn, columns.int32Column, columns.float32Column);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Fill the header unit only (for now) */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; table2 = f.initBintableExt(</div>
<div class="line">      <span class="stringliteral">&quot;TABLE2&quot;</span>,</div>
<div class="line">      columns.stringColumn.info(),</div>
<div class="line">      columns.int32Column.info(),</div>
<div class="line">      columns.float32Column.info());</div>
<div class="line"> </div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__file__handlers.html" title="Work with the Fits file structure.">File handlers</a></dd></dl>
<h2><a class="anchor" id="tuto-write-record"></a>
Write records</h2>
<p>Records are read and written through a <code><a class="el" href="classEuclid_1_1Fits_1_1Header.html" title="Reader-writer for the header unit.">Header</a></code> object, which is accessible from an <code><a class="el" href="classEuclid_1_1Fits_1_1ImageHdu.html" title="Image HDU reader-writer.">ImageHdu</a></code> or a <code><a class="el" href="classEuclid_1_1Fits_1_1BintableHdu.html" title="Binary table HDU reader-writer.">BintableHdu</a></code> as <code>header()</code>. They can be written and updated one-by-one or by sequences.</p>
<p>An optional template parameter controls the write policy, e.g. what to do if the given keyword already exists. By default, a record is created if the keyword doesn't exists, or updated if the keyword already exists.</p>
<p><a class="el" href="structEuclid_1_1Fits_1_1Record.html" title="Keyword-value pair with optional unit and comment.">Record</a> writing functions have different overloards to allow calling them in different ways. Here are a few examples:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">/* Write a single record */</span></div>
<div class="line"> </div>
<div class="line">  hdu.<a class="code" href="classEuclid_1_1Fits_1_1Hdu_a47a1c9c336ac4c61d5586fa1c5bd73b8.html#a47a1c9c336ac4c61d5586fa1c5bd73b8">header</a>().<a class="code" href="classEuclid_1_1Fits_1_1Header_a5bd368987d648821805ce1b184d5e615.html#a5bd368987d648821805ce1b184d5e615">write</a>(records.stringRecord);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Write several records */</span></div>
<div class="line"> </div>
<div class="line">  hdu.<a class="code" href="classEuclid_1_1Fits_1_1Hdu_a47a1c9c336ac4c61d5586fa1c5bd73b8.html#a47a1c9c336ac4c61d5586fa1c5bd73b8">header</a>().<a class="code" href="classEuclid_1_1Fits_1_1Header_a2ad45401d2d15e169e5508db6e650f6b.html#a2ad45401d2d15e169e5508db6e650f6b">writeSeq</a>(records.intRecord, records.floatRecord, records.complexRecord);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Update using initialization lists */</span></div>
<div class="line"> </div>
<div class="line">  hdu.<a class="code" href="classEuclid_1_1Fits_1_1Hdu_a47a1c9c336ac4c61d5586fa1c5bd73b8.html#a47a1c9c336ac4c61d5586fa1c5bd73b8">header</a>().<a class="code" href="classEuclid_1_1Fits_1_1Header_a2ad45401d2d15e169e5508db6e650f6b.html#a2ad45401d2d15e169e5508db6e650f6b">writeSeq</a>&lt;<a class="code" href="group__header__handlers_gaa4bfa592786bf92af22d3f485369faed.html#ggaa4bfa592786bf92af22d3f485369faeda6167bfb4b601d3c4347f7c2d94181479">Fits::RecordMode::UpdateExisting</a>&gt;(</div>
<div class="line">      Fits::Record&lt;int&gt;(<span class="stringliteral">&quot;INT&quot;</span>, 1),</div>
<div class="line">      Fits::Record&lt;float&gt;(<span class="stringliteral">&quot;FLOAT&quot;</span>, 3.14159F, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;A larger piece of Pi&quot;</span>),</div>
<div class="line">      Fits::Record&lt;std::complex&lt;double&gt;&gt;(<span class="stringliteral">&quot;COMPLEX&quot;</span>, { 180., 90. }));</div>
<div class="line"> </div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__header__handlers.html" title="Read and write header units.">Header unit handlers</a></dd></dl>
<h2><a class="anchor" id="tuto-write-image"></a>
Write image data</h2>
<p>Remember that we have left <code>IMAGE2</code> extension without data? Filling it is done through the <code><a class="el" href="classEuclid_1_1Fits_1_1ImageRaster.html" title="Reader-writer for the image data unit.">ImageRaster</a></code> class, accessed as <code><a class="el" href="classEuclid_1_1Fits_1_1ImageHdu_a2c3844d05f16da28fe3e9c357cc31bac.html#a2c3844d05f16da28fe3e9c357cc31bac" title="Access the data unit to read and write the raster.">ImageHdu::raster()</a></code>. For example, here is how to write all the pixels at once:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  image2.raster().write(rasters.int16Raster2D);</div>
<div class="line"> </div>
</div><!-- fragment --><p> Many more options are available to write data region-wise. They are described in details in <a class="el" href="group__image__handlers.html">Image data unit handlers</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__image__handlers.html" title="Read and write image HDUs.">Image data unit handlers</a></dd></dl>
<h2><a class="anchor" id="tuto-write-bintable"></a>
Write binary table data</h2>
<p>Analogously to <code><a class="el" href="classEuclid_1_1Fits_1_1ImageRaster.html" title="Reader-writer for the image data unit.">ImageRaster</a></code> for image HDUs, <code><a class="el" href="classEuclid_1_1Fits_1_1BintableColumns.html" title="Column-wise reader-writer for the binary table data unit.">BintableColumns</a></code> provides read/write services for the data unit of the binary table extension.</p>
<p>As the name implies, data is stored, read and written column-wise, as opposed to the row-major ordering of the <a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write Fits file contents.">Fits</a> file. This is to avoid working with very complex structures like tuples with holes, and rather rely on <code><a class="el" href="classEuclid_1_1Fits_1_1Column.html" title="Binary table column data and metadata.">Column</a></code>, <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html" title="STL class.">std::vector</a></code>, arrays... Yet, this also means that I/Os <em>could</em> be very inefficient! To workaround this, several columns can be written (and read) at a time. In this case, I/Os are internally performed chunk-wise, using some buffer, and performances drammatically improve.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">/* Write a single column */</span></div>
<div class="line"> </div>
<div class="line">  table2.columns().write(columns.stringColumn);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Write several columns */</span></div>
<div class="line"> </div>
<div class="line">  table2.columns().writeSeq(columns.int32Column, columns.float32Column);</div>
<div class="line"> </div>
</div><!-- fragment --><p> Like for image HDUs, it is possible to write the data unit only partially, e.g. to append rows, using richer methods of <code><a class="el" href="classEuclid_1_1Fits_1_1BintableColumns.html" title="Column-wise reader-writer for the binary table data unit.">BintableColumns</a></code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__bintable__handlers.html" title="Read and write binary table HDUs.">Binary table data unit handlers</a></dd></dl>
<h1><a class="anchor" id="tuto-read"></a>
Read a MEF file</h1>
<h2><a class="anchor" id="tuto-access-hdu"></a>
Access HDUs</h2>
<p>HDUs can be accessed with a set of methods, templated with the type of HDU: <code><a class="el" href="classEuclid_1_1Fits_1_1BintableHdu.html" title="Binary table HDU reader-writer.">BintableHdu</a></code>, <code><a class="el" href="classEuclid_1_1Fits_1_1ImageHdu.html" title="Image HDU reader-writer.">ImageHdu</a></code>, or <code><a class="el" href="classEuclid_1_1Fits_1_1Hdu.html" title="Base class for ImageHdu and BintableHdu.">Hdu</a></code>. For metadata work, we don't need to know the type of HDU: whether this is an image or binary table HDU has no impact, and a <code><a class="el" href="classEuclid_1_1Fits_1_1Hdu.html" title="Base class for ImageHdu and BintableHdu.">Hdu</a></code> will be returned by default.</p>
<p>HDUs are accessed either by their name (first HDU whose name matches argument is returned) or by their index, and a shortcut is provided for the primary HDU (which has index 0):</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">/* Access the Primary HDU */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; primary = f.primary();</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> primaryIndex = primary.index();</div>
<div class="line">  <span class="comment">// Indices are 0-based.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Access an HDU by its index */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; image2 = f.access&lt;Fits::ImageHdu&gt;(2);</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> imageName = image2.<a class="code" href="classEuclid_1_1Fits_1_1Hdu.html#a513dbdecf683da5c7f86cf8152750b40">readName</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Access an HDU by its name */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; table1 = f.accessFirst&lt;Fits::BintableHdu&gt;(<span class="stringliteral">&quot;TABLE1&quot;</span>);</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> tableIndex = table1.<a class="code" href="classEuclid_1_1Fits_1_1Hdu.html#a3b1625cec9216ca5ccdf8fb6b4e59b9e">index</a>();</div>
<div class="line">  <span class="comment">// If several HDUs have the same name, the first one is returned.</span></div>
<div class="line"> </div>
</div><!-- fragment --><p> You've probably noticed that we use references to <em>constant</em> HDU handlers. Indeed, HDU handlers are not modified by reading and writing services, only the <code><a class="el" href="classEuclid_1_1Fits_1_1MefFile.html" title="Multi-Extension Fits file reader-writer.">MefFile</a></code> is. Actually, HDU-level and data unit-level handlers are very light classes which aim at providing a clear interface.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__file__handlers.html" title="Work with the Fits file structure.">File handlers</a></dd></dl>
<h2><a class="anchor" id="tuto-read-record"></a>
Parse records</h2>
<p><code><a class="el" href="structEuclid_1_1Fits_1_1Record.html" title="Keyword-value pair with optional unit and comment.">Record</a></code>s are parsed using <code><a class="el" href="classEuclid_1_1Fits_1_1Header.html" title="Reader-writer for the header unit.">Header</a></code> services. Like for writing, you can parse several records at once:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">/* Read a single record */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> intRecord = hdu.<a class="code" href="classEuclid_1_1Fits_1_1Hdu_a47a1c9c336ac4c61d5586fa1c5bd73b8.html#a47a1c9c336ac4c61d5586fa1c5bd73b8">header</a>().<a class="code" href="classEuclid_1_1Fits_1_1Header_af4464865a961ce1a7cc804cc09ef54b3.html#af4464865a961ce1a7cc804cc09ef54b3">parse</a>&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;INT&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Records can be sliced as their value for immediate use:</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> intValue = hdu.<a class="code" href="classEuclid_1_1Fits_1_1Hdu_a47a1c9c336ac4c61d5586fa1c5bd73b8.html#a47a1c9c336ac4c61d5586fa1c5bd73b8">header</a>().<a class="code" href="classEuclid_1_1Fits_1_1Header_af4464865a961ce1a7cc804cc09ef54b3.html#af4464865a961ce1a7cc804cc09ef54b3">parse</a>&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;INT&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Read several records */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> someRecords = hdu.<a class="code" href="classEuclid_1_1Fits_1_1Hdu_a47a1c9c336ac4c61d5586fa1c5bd73b8.html#a47a1c9c336ac4c61d5586fa1c5bd73b8">header</a>().<a class="code" href="classEuclid_1_1Fits_1_1Header_a800ff1df9ab1f288ee3f84b1b3c84717.html#a800ff1df9ab1f288ee3f84b1b3c84717">parseSeq</a>(</div>
<div class="line">      Fits::Named&lt;std::string&gt;(<span class="stringliteral">&quot;STRING&quot;</span>),</div>
<div class="line">      Fits::Named&lt;int&gt;(<span class="stringliteral">&quot;INT&quot;</span>),</div>
<div class="line">      Fits::Named&lt;float&gt;(<span class="stringliteral">&quot;FLOAT&quot;</span>),</div>
<div class="line">      Fits::Named&lt;std::complex&lt;double&gt;&gt;(<span class="stringliteral">&quot;COMPLEX&quot;</span>));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; thirdRecord = std::get&lt;2&gt;(someRecords);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Read as VariantValue */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> variantRecords = hdu.<a class="code" href="classEuclid_1_1Fits_1_1Hdu_a47a1c9c336ac4c61d5586fa1c5bd73b8.html#a47a1c9c336ac4c61d5586fa1c5bd73b8">header</a>().<a class="code" href="classEuclid_1_1Fits_1_1Header_a800ff1df9ab1f288ee3f84b1b3c84717.html#a800ff1df9ab1f288ee3f84b1b3c84717">parseSeq</a>&lt;&gt;({ <span class="stringliteral">&quot;INT&quot;</span>, <span class="stringliteral">&quot;COMPLEX&quot;</span> });</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> complexRecord = variantRecords.as&lt;<a class="codeRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex&lt;double&gt;</a>&gt;(<span class="stringliteral">&quot;COMPLEX&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Read as a user-defined structure */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> tutoRecords = hdu.<a class="code" href="classEuclid_1_1Fits_1_1Hdu_a47a1c9c336ac4c61d5586fa1c5bd73b8.html#a47a1c9c336ac4c61d5586fa1c5bd73b8">header</a>().<a class="code" href="classEuclid_1_1Fits_1_1Header_aede5f608b15cd46808cd08ca7fc42b7c.html#aede5f608b15cd46808cd08ca7fc42b7c">parseStruct</a>&lt;TutoRecords&gt;(</div>
<div class="line">      Fits::Named&lt;std::string&gt;(<span class="stringliteral">&quot;STRING&quot;</span>),</div>
<div class="line">      Fits::Named&lt;int&gt;(<span class="stringliteral">&quot;INT&quot;</span>),</div>
<div class="line">      Fits::Named&lt;float&gt;(<span class="stringliteral">&quot;FLOAT&quot;</span>),</div>
<div class="line">      Fits::Named&lt;std::complex&lt;double&gt;&gt;(<span class="stringliteral">&quot;COMPLEX&quot;</span>));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; stringRecord = tutoRecords.stringRecord;</div>
<div class="line"> </div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__header__handlers.html" title="Read and write header units.">Header unit handlers</a></dd></dl>
<h2><a class="anchor" id="tuto-read-image"></a>
Read image data</h2>
<p>Like for writing, reading images is ensured by <code><a class="el" href="classEuclid_1_1Fits_1_1ImageRaster.html" title="Reader-writer for the image data unit.">ImageRaster</a></code>. A <code><a class="el" href="classEuclid_1_1Fits_1_1VecRaster.html" title="Copy constructor.">VecRaster</a></code> is generally instantiated, and pixel values can be accessed with the subscript operator <code>[]</code>:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> image = hdu.raster().read&lt;<a class="codeRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int16_t</a>, 2&gt;();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; firstPixel = image[{ 0, 0 }];</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; lastPixel = image.at({ -1, -1 });</div>
<div class="line">  <span class="comment">// `operator[]` performs no bound checking, while `at` does and enables backward indexing.</span></div>
<div class="line"> </div>
</div><!-- fragment --><p> Again, regions can be read.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__image__handlers.html" title="Read and write image HDUs.">Image data unit handlers</a></dd></dl>
<h2><a class="anchor" id="tuto-read-bintable"></a>
Read binary table data</h2>
<p><a class="el" href="classEuclid_1_1Fits_1_1Column.html" title="Binary table column data and metadata.">Column</a> reading is provided by <code><a class="el" href="classEuclid_1_1Fits_1_1BintableColumns.html" title="Column-wise reader-writer for the binary table data unit.">BintableColumns</a></code>. Columns are generally read as <code><a class="el" href="classEuclid_1_1Fits_1_1VecColumn.html" title="Column which stores internally the data.">VecColumn</a></code>s, values of which are accessed with the call operator <code>()</code>:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">/* Read a single column */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> vectorColumn = hdu.<a class="code" href="classEuclid_1_1Fits_1_1BintableHdu.html#a5085b93a1c50e74e6a0dd4b527be6638">readColumn</a>&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;VECTOR&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Read several columns by their name */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> byName = hdu.<a class="code" href="classEuclid_1_1Fits_1_1BintableHdu_acfa7bf275903196800d1619aa2ff7fe2.html#acfa7bf275903196800d1619aa2ff7fe2">columns</a>().<a class="code" href="classEuclid_1_1Fits_1_1BintableColumns_a28d318415c6e7363941fb2c88cd9a1b1.html#a28d318415c6e7363941fb2c88cd9a1b1">readSeq</a>(Fits::Named&lt;std::string&gt;(<span class="stringliteral">&quot;STRING&quot;</span>), Fits::Named&lt;std::int32_t&gt;(<span class="stringliteral">&quot;INT32&quot;</span>));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; stringColumn = std::get&lt;0&gt;(byName);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Read several columns by their index */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> byIndex = hdu.<a class="code" href="classEuclid_1_1Fits_1_1BintableHdu_acfa7bf275903196800d1619aa2ff7fe2.html#acfa7bf275903196800d1619aa2ff7fe2">columns</a>().<a class="code" href="classEuclid_1_1Fits_1_1BintableColumns_a28d318415c6e7363941fb2c88cd9a1b1.html#a28d318415c6e7363941fb2c88cd9a1b1">readSeq</a>(Fits::Indexed&lt;std::string&gt;(0), Fits::Indexed&lt;std::int32_t&gt;(1));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; intColumn = std::get&lt;1&gt;(byIndex);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Use values */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; firstString = stringColumn(0);</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; firstInt = intColumn(0);</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; lastFloat = vectorColumn.at(-1, -1);</div>
<div class="line">  <span class="comment">// There is no operator[]() for columns, because vector columns require 2 indices (row and repeat).</span></div>
<div class="line">  <span class="comment">// operator()() performs no bound checking, while at() does and enables backward indexing.</span></div>
<div class="line"> </div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__bintable__handlers.html" title="Read and write binary table HDUs.">Binary table data unit handlers</a></dd></dl>
<h1><a class="anchor" id="tuto-conclusion"></a>
Wrap up</h1>
<p>A picture is worth a thousand words; below is the class diagram of what we've just learned (i.e. the main contents of the <code><a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write Fits file contents.">Euclid::Fits</a></code> namespace).</p>
<p>To go further or out of curiosity, head to the <a href="modules.html">module pages</a> or <a href="pages.html">related pages</a>. Specifically, data classes and service classes are described in more details in <a class="el" href="group__data__classes.html">Data classes</a> and <a class="el" href="group__handlers.html">File and HDU handlers</a>. To practice or test your own code, you can also browse the <code><a class="el" href="namespaceEuclid_1_1Fits_1_1Test.html" title="Test-related classes and functions.">Euclid::Fits::Test</a></code> namespace, which provides ready-to-use functions and classes, such as the random records, rasters and columns we've seen above.</p>
<div class="image">
<img src="FitsData.png" alt=""/>
</div>
<div class="image">
<img src="FitsFile.png" alt=""/>
</div>
 </div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="amove_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/utility/move.html">std::move</a></div><div class="ttdeci">T move(T... args)</div></div>
<div class="ttc" id="avector_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></div><div class="ttdoc">STL class.</div></div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1BintableHdu_acfa7bf275903196800d1619aa2ff7fe2_html_acfa7bf275903196800d1619aa2ff7fe2"><div class="ttname"><a href="classEuclid_1_1Fits_1_1BintableHdu_acfa7bf275903196800d1619aa2ff7fe2.html#acfa7bf275903196800d1619aa2ff7fe2">Euclid::Fits::BintableHdu::columns</a></div><div class="ttdeci">const BintableColumns &amp; columns() const</div><div class="ttdoc">Access the data unit column-wise.</div></div>
<div class="ttc" id="agroup__header__handlers_gaa4bfa592786bf92af22d3f485369faed_html_ggaa4bfa592786bf92af22d3f485369faeda6167bfb4b601d3c4347f7c2d94181479"><div class="ttname"><a href="group__header__handlers_gaa4bfa592786bf92af22d3f485369faed.html#ggaa4bfa592786bf92af22d3f485369faeda6167bfb4b601d3c4347f7c2d94181479">Euclid::Fits::RecordMode::CreateOrUpdate</a></div><div class="ttdeci">@ CreateOrUpdate</div><div class="ttdoc">Modify a record if keyword already exists, create a record otherwise.</div></div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1Header_af4464865a961ce1a7cc804cc09ef54b3_html_af4464865a961ce1a7cc804cc09ef54b3"><div class="ttname"><a href="classEuclid_1_1Fits_1_1Header_af4464865a961ce1a7cc804cc09ef54b3.html#af4464865a961ce1a7cc804cc09ef54b3">Euclid::Fits::Header::parse</a></div><div class="ttdeci">Record&lt; T &gt; parse(const std::string &amp;keyword) const</div><div class="ttdoc">Parse a record.</div></div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1Header_a800ff1df9ab1f288ee3f84b1b3c84717_html_a800ff1df9ab1f288ee3f84b1b3c84717"><div class="ttname"><a href="classEuclid_1_1Fits_1_1Header_a800ff1df9ab1f288ee3f84b1b3c84717.html#a800ff1df9ab1f288ee3f84b1b3c84717">Euclid::Fits::Header::parseSeq</a></div><div class="ttdeci">RecordVec&lt; T &gt; parseSeq(const std::vector&lt; std::string &gt; &amp;keywords) const</div><div class="ttdoc">Parse a sequence of homogeneous records.</div></div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1Hdu_html_a3b1625cec9216ca5ccdf8fb6b4e59b9e"><div class="ttname"><a href="classEuclid_1_1Fits_1_1Hdu.html#a3b1625cec9216ca5ccdf8fb6b4e59b9e">Euclid::Fits::Hdu::index</a></div><div class="ttdeci">long index() const</div><div class="ttdoc">Get the 0-based index of the HDU.</div></div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1Hdu_html_a513dbdecf683da5c7f86cf8152750b40"><div class="ttname"><a href="classEuclid_1_1Fits_1_1Hdu.html#a513dbdecf683da5c7f86cf8152750b40">Euclid::Fits::Hdu::readName</a></div><div class="ttdeci">std::string readName() const</div><div class="ttdoc">Read the extension name.</div></div>
<div class="ttc" id="ato_string_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/string/basic_string/to_string.html">std::to_string</a></div><div class="ttdeci">T to_string(T... args)</div></div>
<div class="ttc" id="ainteger_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/types/integer.html">std::int16_t</a></div></div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1Header_a2ad45401d2d15e169e5508db6e650f6b_html_a2ad45401d2d15e169e5508db6e650f6b"><div class="ttname"><a href="classEuclid_1_1Fits_1_1Header_a2ad45401d2d15e169e5508db6e650f6b.html#a2ad45401d2d15e169e5508db6e650f6b">Euclid::Fits::Header::writeSeq</a></div><div class="ttdeci">void writeSeq(const Record&lt; Ts &gt; &amp;... records) const</div><div class="ttdoc">Write a homogeneous sequence of records.</div></div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1Header_a5bd368987d648821805ce1b184d5e615_html_a5bd368987d648821805ce1b184d5e615"><div class="ttname"><a href="classEuclid_1_1Fits_1_1Header_a5bd368987d648821805ce1b184d5e615.html#a5bd368987d648821805ce1b184d5e615">Euclid::Fits::Header::write</a></div><div class="ttdeci">void write(const Record&lt; T &gt; &amp;record) const</div><div class="ttdoc">Write a record.</div></div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1Header_aede5f608b15cd46808cd08ca7fc42b7c_html_aede5f608b15cd46808cd08ca7fc42b7c"><div class="ttname"><a href="classEuclid_1_1Fits_1_1Header_aede5f608b15cd46808cd08ca7fc42b7c.html#aede5f608b15cd46808cd08ca7fc42b7c">Euclid::Fits::Header::parseStruct</a></div><div class="ttdeci">TOut parseStruct(const Named&lt; Ts &gt; &amp;... keywords) const</div><div class="ttdoc">Parse a sequence of records.</div></div>
<div class="ttc" id="acomplex_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex&lt; double &gt;</a></div></div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1BintableHdu_html_a5085b93a1c50e74e6a0dd4b527be6638"><div class="ttname"><a href="classEuclid_1_1Fits_1_1BintableHdu.html#a5085b93a1c50e74e6a0dd4b527be6638">Euclid::Fits::BintableHdu::readColumn</a></div><div class="ttdeci">VecColumn&lt; T &gt; readColumn(long index) const</div><div class="ttdoc">Read a column with given index.</div></div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1Hdu_a47a1c9c336ac4c61d5586fa1c5bd73b8_html_a47a1c9c336ac4c61d5586fa1c5bd73b8"><div class="ttname"><a href="classEuclid_1_1Fits_1_1Hdu_a47a1c9c336ac4c61d5586fa1c5bd73b8.html#a47a1c9c336ac4c61d5586fa1c5bd73b8">Euclid::Fits::Hdu::header</a></div><div class="ttdeci">const Header &amp; header() const</div><div class="ttdoc">Access the header unit to read and write records.</div></div>
<div class="ttc" id="anamespaceEuclid_html"><div class="ttname"><a href="namespaceEuclid.html">Euclid</a></div><div class="ttdoc">Euclid SGS namespace.</div><div class="ttdef"><b>Definition:</b> cfitsio_toc.dox:1</div></div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1BintableColumns_a28d318415c6e7363941fb2c88cd9a1b1_html_a28d318415c6e7363941fb2c88cd9a1b1"><div class="ttname"><a href="classEuclid_1_1Fits_1_1BintableColumns_a28d318415c6e7363941fb2c88cd9a1b1.html#a28d318415c6e7363941fb2c88cd9a1b1">Euclid::Fits::BintableColumns::readSeq</a></div><div class="ttdeci">std::tuple&lt; VecColumn&lt; Ts &gt;... &gt; readSeq(const Named&lt; Ts &gt; &amp;... names) const</div><div class="ttdoc">Read the columns with given names.</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.19
</small></address>
</body>
</html>
