<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.19"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EleFits: Header data classes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="elefits_notext.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EleFits
   &#160;<span id="projectnumber">4.0.0</span>
   </div>
   <div id="projectbrief">A modern C++ API on top of CFitsIO</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.19 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Header data classes<div class="ingroups"><a class="el" href="group__data__classes.html">Data classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Classes to manipulate the data stored header units. </p>
<h1><a class="anchor" id="header_data_classes-record"></a>
Record</h1>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The value type, which can be an integer, floating point, complex, <code><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html" title="STL class.">std::string</a></code>, <code>const char *</code>, or <code>VariantValue</code> for run-time type deduction.</td></tr>
  </table>
  </dd>
</dl>
<p>Here's a record of type <code>double</code> with keyword <code>"LIGHT"</code>, value <code>3.0e8</code>, unit <code>"m/s"</code> and comment <code>"speed of light"</code>: </p><div class="fragment"><div class="line">Record&lt;double&gt; lightSpeed { <span class="stringliteral">&quot;LIGHT&quot;</span>, 3.0e8, <span class="stringliteral">&quot;m/s&quot;</span>, <span class="stringliteral">&quot;speed of light&quot;</span> };</div>
</div><!-- fragment --><p>In the <a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write Fits file contents.">Fits</a> file, this record will appear in the header of an HDU as (padding blank spaces removed): </p><div class="fragment"><div class="line">LIGHT = 3.0E8 / [m/s] speed of light</div>
</div><!-- fragment --><p>In the <a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write Fits file contents.">Fits</a> definition, it is unclear if the "comment" encompasses only: <code>speed of light</code>, or also the unit, as: <code>[m/s] speed of light</code>. In EleFits, the former is named comment, while the latter is the raw comment. The raw comment can be get as <code><a class="el" href="structEuclid_1_1Fits_1_1Record_ac1d07992fd2e43f82c2a4441ae7bac4a.html#ac1d07992fd2e43f82c2a4441ae7bac4a" title="Get the raw comment string.">Record::rawComment()</a></code>.</p>
<p>Such a <code><a class="el" href="structEuclid_1_1Fits_1_1Record.html" title="Keyword-value pair with optional unit and comment.">Record</a></code> can be cast to <code>double</code> (records of value type <code>T</code> can be cast to <code>T</code>), or more precisely, it can be sliced as its value. </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> milleniumFalconSpeed = 1.5 * lightSpeed;</div>
<div class="line"><span class="comment">// Same as: 1.5 * lightSpeed.value</span></div>
</div><!-- fragment --><p>This is also usefull when aiming at reading record values only, and skip the keyword, unit and comment: </p><div class="fragment"><div class="line">Record&lt;int&gt; theRecord = header.read&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;KEYWORD&quot;</span>);</div>
<div class="line"><span class="keywordtype">int</span> theValue = header.read&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;KEYWORD&quot;</span>);</div>
</div><!-- fragment --><p>The "HIERARCH" convention for extended keywords is supported. It occurs when the keyword is longer than 8 characters, or contains non-standard characters like spaces or symbols. Such records are read and written transparently as: </p><div class="fragment"><div class="line">HIERARCH the_long_keyword = value / [unit] comment</div>
</div><!-- fragment --><p> The maximum length of such a keyword is 67 characters, which gives room for a 1-byte long value.</p>
<p>CFitsIO convention on long string values (more than 68 characters) is supported. When writing a long string record, the value is wrapped automatically, and each new line starts with the CONTINUE keyword. An additional "LONGSTRN" record is written to the file, to warn the file user about the CFitsIO convention.</p>
<h1><a class="anchor" id="header_data_classes-recordvec"></a>
RecordVec, RecordSeq</h1>
<p>Passing a large number of records around can be complex, all the more if the value types are different given how cumbersome it would be to use <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a></code> of various <code><a class="el" href="structEuclid_1_1Fits_1_1Record.html" title="Keyword-value pair with optional unit and comment.">Record</a></code>s.</p>
<p>Two record containers are provided to ease this:</p><ul>
<li><code><a class="el" href="classEuclid_1_1Fits_1_1RecordVec.html" title="A vector of records with find and conversion services.">RecordVec</a></code> is a homogeneous container, i.e. the value type is the same for each contained record;</li>
<li><code>RecordSeq</code> is an alias for <code><a class="el" href="classEuclid_1_1Fits_1_1RecordVec.html" title="A vector of records with find and conversion services.">RecordVec</a>&lt;VariantValue&gt;</code>, which represents a run-time tuple.</li>
</ul>
<p>Records in those containers are convertible thanks to an internal casting system. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga33f1a40abc8fe7417fe104eb19db37e3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__data__classes_ga33f1a40abc8fe7417fe104eb19db37e3.html#ga33f1a40abc8fe7417fe104eb19db37e3">Euclid::Fits::VariantValue</a> = boost::any</td></tr>
<tr class="memdesc:ga33f1a40abc8fe7417fe104eb19db37e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variant value type for records.  <a href="group__header__data__classes_ga33f1a40abc8fe7417fe104eb19db37e3.html#ga33f1a40abc8fe7417fe104eb19db37e3">More...</a><br /></td></tr>
<tr class="separator:ga33f1a40abc8fe7417fe104eb19db37e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7b97d9c6f0cb9f1044a5bccbe823678"><td class="memItemLeft" align="right" valign="top"><a id="gae7b97d9c6f0cb9f1044a5bccbe823678"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__data__classes.html#gae7b97d9c6f0cb9f1044a5bccbe823678">Euclid::Fits::RecordSeq</a> = <a class="el" href="classEuclid_1_1Fits_1_1RecordVec.html">RecordVec</a>&lt; <a class="el" href="group__header__data__classes_ga33f1a40abc8fe7417fe104eb19db37e3.html#ga33f1a40abc8fe7417fe104eb19db37e3">VariantValue</a> &gt;</td></tr>
<tr class="memdesc:gae7b97d9c6f0cb9f1044a5bccbe823678"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequence of records of any type. <br /></td></tr>
<tr class="separator:gae7b97d9c6f0cb9f1044a5bccbe823678"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEuclid_1_1Fits_1_1Record.html">Euclid::Fits::Record&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keyword-value pair with optional unit and comment.  <a href="structEuclid_1_1Fits_1_1Record.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEuclid_1_1Fits_1_1RecordVec.html">Euclid::Fits::RecordVec&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector of records with find and conversion services.  <a href="classEuclid_1_1Fits_1_1RecordVec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaaa9eea5a044aa06ba850b2422da9f536"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__data__classes_gaaa9eea5a044aa06ba850b2422da9f536.html#gaaa9eea5a044aa06ba850b2422da9f536">ELEFITS_FOREACH_RECORD_TYPE</a>(MACRO)</td></tr>
<tr class="memdesc:gaaa9eea5a044aa06ba850b2422da9f536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop over supported record types.  <a href="group__header__data__classes_gaaa9eea5a044aa06ba850b2422da9f536.html#gaaa9eea5a044aa06ba850b2422da9f536">More...</a><br /></td></tr>
<tr class="separator:gaaa9eea5a044aa06ba850b2422da9f536"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga72fc1a3ca2dc39a56a8a789454fb24a6"><td class="memTemplParams" colspan="2"><a id="ga72fc1a3ca2dc39a56a8a789454fb24a6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga72fc1a3ca2dc39a56a8a789454fb24a6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__header__data__classes.html#ga72fc1a3ca2dc39a56a8a789454fb24a6">Euclid::Fits::operator!=</a> (const <a class="el" href="structEuclid_1_1Fits_1_1Record.html">Record</a>&lt; T &gt; &amp;lhs, const <a class="el" href="structEuclid_1_1Fits_1_1Record.html">Record</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga72fc1a3ca2dc39a56a8a789454fb24a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether two records are different. <br /></td></tr>
<tr class="separator:ga72fc1a3ca2dc39a56a8a789454fb24a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<div class="ttc" id="abasic_string_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a></div><div class="ttdoc">STL class.</div></div>
<div class="ttc" id="acomplex_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex&lt; float &gt;</a></div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.19
</small></address>
</body>
</html>
