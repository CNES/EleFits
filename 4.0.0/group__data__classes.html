<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.19"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EleFits: Data classes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="elefits_notext.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EleFits
   &#160;<span id="projectnumber">4.0.0</span>
   </div>
   <div id="projectbrief">A modern C++ API on top of CFitsIO</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.19 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<div class="title">Data classes</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Classes to represent the data stored in a <a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write Fits file contents.">Fits</a> file. </p>
<h1><a class="anchor" id="data-record"></a>
Records</h1>
<p><code><a class="el" href="structEuclid_1_1Fits_1_1Record.html" title="Keyword-value pair with optional unit and comment.">Record</a></code> is a very basic template structure which holds the following four fields:</p><ul>
<li>keyword,</li>
<li>value,</li>
<li>unit</li>
<li>comment.</li>
</ul>
<p>Its template parameter is the type of the value.</p>
<p>Here's a record of type <code>double</code> with keyword <code>"LIGHT"</code>, value <code>3.0e8</code>, unit <code>"m/s"</code> and comment <code>"speed of light"</code>: </p><div class="fragment"><div class="line">Record&lt;double&gt; lightSpeed { <span class="stringliteral">&quot;LIGHT&quot;</span>, 3.0e8, <span class="stringliteral">&quot;m/s&quot;</span>, <span class="stringliteral">&quot;speed of light&quot;</span> };</div>
</div><!-- fragment --><p>In the <a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write Fits file contents.">Fits</a> file, this record will appear in the header of an HDU as (padding blank spaces removed): </p><pre class="fragment">LIGHT = 3.0E8 / [m/s] speed of light
</pre><p>In the <a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write Fits file contents.">Fits</a> definition, it is unclear if the "comment" encompasses only <code>speed of light</code> or <code>[m/s] speed of light</code>. In EleFits, the former is named comment, while the latter is the raw comment. The raw comment can be get as <code><a class="el" href="structEuclid_1_1Fits_1_1Record_ac1d07992fd2e43f82c2a4441ae7bac4a.html#ac1d07992fd2e43f82c2a4441ae7bac4a" title="Get the raw comment string.">Record::rawComment()</a></code>.</p>
<p>Such a <code><a class="el" href="structEuclid_1_1Fits_1_1Record.html" title="Keyword-value pair with optional unit and comment.">Record</a></code> can be cast to <code>double</code> (records of value type <code>T</code> can be cast to <code>T</code>), or more precisely, it can be sliced as its value. </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> milleniumFalconSpeed = 1.5 * lightSpeed;</div>
<div class="line"><span class="comment">// Same as: 1.5 * lightSpeed.value</span></div>
</div><!-- fragment --><p>This is also usefull when aiming at reading record values only, and skip the keyword, unit and comment: </p><div class="fragment"><div class="line">Record&lt;int&gt; theRecord = header.read&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;KEYWORD&quot;</span>);</div>
<div class="line"><span class="keywordtype">int</span> theValue = header.read&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;KEYWORD&quot;</span>);</div>
</div><!-- fragment --><h1><a class="anchor" id="data-raster"></a>
Rasters</h1>
<p><code><a class="el" href="classEuclid_1_1Fits_1_1Raster.html" title="Raster of a n-dimensional image (2D by default).">Raster</a></code>s are the in-memory representation of the <em>n</em>-D arrays of <a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write Fits file contents.">Fits</a>. A raster has:</p><ul>
<li>a dimension (number of axes) as a template parameter,</li>
<li>a value type as a template parameter,</li>
<li>a shape (of type <code><a class="el" href="structEuclid_1_1Fits_1_1Position.html" title="n-dimensional pixel position or image shape, i.e. set of integer coordinates.">Position</a></code>, which is just an alias of <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html" title="STL class.">std::array</a></code> or <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html" title="STL class.">std::vector</a></code>),</li>
<li>some data, i.e. the pixel values, stored contiguously, for example in a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html" title="STL class.">std::vector</a></code>.</li>
</ul>
<p>There are two ways of defining a <code><a class="el" href="classEuclid_1_1Fits_1_1Raster.html" title="Raster of a n-dimensional image (2D by default).">Raster</a></code>:</p><ul>
<li>when the dimension is knwon at compile-time, by giving the dimensions parameter a positive or null value;</li>
<li>when the dimension is known at run-time only, by assigning -1 to the dimensions parameter.</li>
</ul>
<p>In the former case, index and size computations are optimized, and the dimension is enforced. For example, it is not possible to read a 3D image HDU as a 2D <code><a class="el" href="classEuclid_1_1Fits_1_1Raster.html" title="Raster of a n-dimensional image (2D by default).">Raster</a></code>. Which is nice, because an exception will be raise early! In contrast, it is possible to read a 2D image HDU as a 3D <code><a class="el" href="classEuclid_1_1Fits_1_1Raster.html" title="Raster of a n-dimensional image (2D by default).">Raster</a></code> of third axis lenght =1.</p>
<p>In the latter case, the dimension may vary or be deduced from the file, which is also nice sometimes but puts more responsibility on the shoulders of the user code, as it should check that the returned dimension is acceptable.</p>
<p><code><a class="el" href="classEuclid_1_1Fits_1_1Raster.html" title="Raster of a n-dimensional image (2D by default).">Raster</a></code> is an abstract class, to be extended with an actual data container. Two such concrete classes are provided:</p><ul>
<li><code><a class="el" href="classEuclid_1_1Fits_1_1PtrRaster.html" title="Raster of a n-dimensional image (2D by default).">PtrRaster</a></code> merely stores a pointer to the data array;</li>
<li><code><a class="el" href="classEuclid_1_1Fits_1_1VecRaster.html" title="Copy constructor.">VecRaster</a></code> owns itself the data as an <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html" title="STL class.">std::vector</a></code>.</li>
</ul>
<p>You can create your own raster types by inheriting from <code><a class="el" href="classEuclid_1_1Fits_1_1Raster.html" title="Raster of a n-dimensional image (2D by default).">Raster</a></code>.</p>
<p>All functions which return a <code><a class="el" href="classEuclid_1_1Fits_1_1Raster.html" title="Raster of a n-dimensional image (2D by default).">Raster</a></code> really return a <code><a class="el" href="classEuclid_1_1Fits_1_1VecRaster.html" title="Copy constructor.">VecRaster</a></code> (e.g. <code><a class="el" href="classEuclid_1_1Fits_1_1ImageRaster_acaa4394ac05056b89fe188fa1962648a.html#acaa4394ac05056b89fe188fa1962648a" title="Read the whole data unit as a new VecRaster.">ImageRaster::read()</a></code>). All methods which take a <code><a class="el" href="classEuclid_1_1Fits_1_1Raster.html" title="Raster of a n-dimensional image (2D by default).">Raster</a></code> as input accept whatever flavor of it.</p>
<p><code><a class="el" href="classEuclid_1_1Fits_1_1Raster.html" title="Raster of a n-dimensional image (2D by default).">Raster</a></code> ensures constant-time access to elements, whatever the dimension of the data, through subscipt operators <code><a class="el" href="classEuclid_1_1Fits_1_1Raster.html#a577800f837ff0b0054be1e7126772869" title="Pixel at given position.">Raster::operator[]()</a></code>. Bound checking and backward indexing (index &lt;0) are enabled in <code><a class="el" href="classEuclid_1_1Fits_1_1Raster_a01218345562cd9505b286af1d221d37d.html#a01218345562cd9505b286af1d221d37d" title="Access the value at given position.">Raster::at()</a></code>. Here is an excerpt of the <a class="el" href="tuto.html">Tutorial</a> giving a concrete usage example:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">/* Initialize and later fill a raster */</span></div>
<div class="line"> </div>
<div class="line">  Fits::VecRaster&lt;std::int16_t, 2&gt; int16Raster2D({ 4, 3 });</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; position : int16Raster2D.domain()) {</div>
<div class="line">    int16Raster2D[position] = position[0] + position[1];</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// This demonstrates the iteration over positions;</span></div>
<div class="line">  <span class="comment">// It is possible to use two nested loops instead.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Create a raster from a vector */</span></div>
<div class="line"> </div>
<div class="line">  <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;std::int32_t&gt;</a> int32Vec(16 * 9 * 3, 0);</div>
<div class="line">  <span class="comment">// ... do what you have to do with the vector, and then move it to the raster ...</span></div>
<div class="line">  Fits::VecRaster&lt;std::int32_t, 3&gt; int32Raster3D({ 16, 9, 3 }, <a class="codeRef" href="http://en.cppreference.com/w/cpp/utility/move.html">std::move</a>(int32Vec));</div>
<div class="line">  <span class="comment">// Instead of moving a vector, it&#39;s also possible to work with</span></div>
<div class="line">  <span class="comment">// a raw pointer with the PtrRaster class.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Generate a random raster */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> int64Raster4D = Fits::Test::RandomRaster&lt;std::int64_t, 4&gt;({ 17, 9, 3, 24 });</div>
<div class="line"> </div>
</div><!-- fragment --><h1><a class="anchor" id="data-column"></a>
Columns</h1>
<p><code><a class="el" href="classEuclid_1_1Fits_1_1Column.html" title="Binary table column data and metadata.">Column</a></code>s represent the contents of the data unit of binary table HDUs. They are made of two components:</p>
<ul>
<li>metadata as a <code><a class="el" href="structEuclid_1_1Fits_1_1ColumnInfo.html" title="Column metadata, i.e. { name, unit, repeatCount } and the value type as the template parameter.">ColumnInfo</a></code> instance,</li>
<li>data as a whatever-you-want!</li>
</ul>
<p><code><a class="el" href="structEuclid_1_1Fits_1_1ColumnInfo.html" title="Column metadata, i.e. { name, unit, repeatCount } and the value type as the template parameter.">ColumnInfo</a></code> looks like a <code><a class="el" href="structEuclid_1_1Fits_1_1Record.html" title="Keyword-value pair with optional unit and comment.">Record</a></code> without a comment: there is a template parameter for the value type, a name and a unit. Additionally, member <code>repeatCount</code> stores the width of the column: it is 1 for scalar columns and &gt;1 for vector columns.</p>
<p>In order to accommodate whatever-you-want kind of data container, <code><a class="el" href="classEuclid_1_1Fits_1_1Column.html" title="Binary table column data and metadata.">Column</a></code> is an abstract class whose only assumption is that elements are contiguous in memory, so that you are able to provide a raw pointer to the first element of the column.</p>
<p>The library comes with several ready-to-use implementations:</p>
<ul>
<li><code><a class="el" href="classEuclid_1_1Fits_1_1PtrColumn.html" title="Column which references some external pointer data.">PtrColumn</a></code> is the lightest structure: it just knows a pointer to the first element of the column;</li>
<li><code><a class="el" href="classEuclid_1_1Fits_1_1VecColumn.html" title="Column which stores internally the data.">VecColumn</a></code> owns the data as an <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html" title="STL class.">std::vector</a></code> and is compatible with the move semantics.</li>
</ul>
<p>To write a column, any <code><a class="el" href="classEuclid_1_1Fits_1_1Column.html" title="Binary table column data and metadata.">Column</a></code> implementation works: you can even provide your own, e.g. some <code>EigenColumn</code>. <code><a class="el" href="classEuclid_1_1Fits_1_1Column.html" title="Binary table column data and metadata.">Column</a></code>s are always read as <code><a class="el" href="classEuclid_1_1Fits_1_1VecColumn.html" title="Column which stores internally the data.">VecColumn</a></code> instances. If you want to give or steal the data to or from a <code><a class="el" href="classEuclid_1_1Fits_1_1VecColumn.html" title="Column which stores internally the data.">VecColumn</a></code>, you can exploit move semantics, as shown in the <a class="el" href="tuto.html">Tutorial</a>:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">/* Initialize and later fill a column */</span></div>
<div class="line"> </div>
<div class="line">  Fits::VecColumn&lt;std::string&gt; stringColumn({ <span class="stringliteral">&quot;STRING&quot;</span>, <span class="stringliteral">&quot;unit&quot;</span>, 3 }, 100);</div>
<div class="line">  <span class="comment">// String columns must be wide-enough to hold each character.</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; stringColumn.rowCount(); ++i) {</div>
<div class="line">    stringColumn(i) = <a class="codeRef" href="http://en.cppreference.com/w/cpp/string/basic_string/to_string.html">std::to_string</a>(i);</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// operator() takes two parameters: the row index, and repeat index (=0 by default)</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Create a column from a vector */</span></div>
<div class="line"> </div>
<div class="line">  <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;std::int32_t&gt;</a> int32Vec(100);</div>
<div class="line">  <span class="comment">// ... do what you have to do with the vector, and then move it to the column ...</span></div>
<div class="line">  Fits::VecColumn&lt;std::int32_t&gt; int32Column({ <span class="stringliteral">&quot;INT32&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, 1 }, <a class="codeRef" href="http://en.cppreference.com/w/cpp/utility/move.html">std::move</a>(int32Vec));</div>
<div class="line">  <span class="comment">// Analogously to rasters, columns can be managed with the lightweight PtrColumn classe.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Generate a random column */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> float32Column = Fits::Test::RandomVectorColumn&lt;float&gt;(8, 100);</div>
<div class="line"> </div>
</div><!-- fragment --><h1><a class="anchor" id="data-wrapup"></a>
Wrap-up</h1>
<p>We have just learnt the basics of the data classes. They are as-light-as-possible classes which store or reference data. They are the inputs and outputs of the read/write services described in <a class="el" href="group__handlers.html">File and HDU handlers</a>.</p>
<p>To see them in action, follow the <a class="el" href="tuto.html">Tutorial</a>.</p>
<p>To better understand the class design and relationships, you might want to see a UML diagram. Here it is:</p>
<div class="image">
<img src="FitsData.png" alt=""/>
</div>
 <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__header__data__classes"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__header__data__classes.html">Header data classes</a></td></tr>
<tr class="memdesc:group__header__data__classes"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classes to manipulate the data stored header units. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__image__data__classes"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__data__classes.html">Image data classes</a></td></tr>
<tr class="memdesc:group__image__data__classes"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image data containers and tools. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__bintable__data__classes"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bintable__data__classes.html">Binary table data classes</a></td></tr>
<tr class="memdesc:group__bintable__data__classes"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary table data containers and tools. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<div class="ttc" id="amove_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/utility/move.html">std::move</a></div><div class="ttdeci">T move(T... args)</div></div>
<div class="ttc" id="avector_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></div><div class="ttdoc">STL class.</div></div>
<div class="ttc" id="ato_string_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/string/basic_string/to_string.html">std::to_string</a></div><div class="ttdeci">T to_string(T... args)</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.19
</small></address>
</body>
</html>
