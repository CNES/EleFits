<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.9.5" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EleFits: Tutorial</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <div id="top">
      <!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr style="height: 56px;">
              <td id="projectlogo"><a href="https://cnes.github.io/EleFits/"><img alt="Logo"
                    src="elefits_notext.png" /></a></td>
              <td id="projectalign" style="padding-left: 0.5em;">
                <div id="projectname">EleFits
                  <span id="projectnumber">&#160;5.3.0</span>
                </div>
                <div id="projectbrief">A modern C++ API on top of CFITSIO</div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
      <!-- GitHub corner -->
      <a href="https://github.com/CNES/EleFits" class="github-corner" aria-label="View source on GitHub"><svg
          viewBox="0 0 250 250" aria-hidden="true">
          <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
          <path
            d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
            fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
          <path
            d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
            fill="currentColor" class="octo-body"></path>
        </svg></a>
      <!-- GitHub corner --><!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#tuto-intro">Introduction</a></li>
<li class="level1"><a href="#tuto-setup">Setup</a></li>
<li class="level1"><a href="#tuto-data-classes">Data classes</a><ul><li class="level2"><a href="#tuto-record">Record</a></li>
<li class="level2"><a href="#tuto-raster">Raster</a></li>
<li class="level2"><a href="#tuto-column">Column</a></li>
</ul>
</li>
<li class="level1"><a href="#tuto-file">Open (and close) a MEF file</a></li>
<li class="level1"><a href="#tuto-write">Write a MEF file</a><ul><li class="level2"><a href="#tuto-write-ext">Create extensions</a></li>
<li class="level2"><a href="#tuto-write-record">Write records</a></li>
<li class="level2"><a href="#tuto-write-image">Write image data</a></li>
<li class="level2"><a href="#tuto-write-bintable">Write binary table data</a></li>
</ul>
</li>
<li class="level1"><a href="#tuto-read">Read a MEF file</a><ul><li class="level2"><a href="#tuto-access-hdu">Access HDUs</a></li>
<li class="level2"><a href="#tuto-read-record">Parse records</a></li>
<li class="level2"><a href="#tuto-read-image">Read image data</a></li>
<li class="level2"><a href="#tuto-read-bintable">Read binary table data</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="tuto-intro"></a>
Introduction</h1>
<p >In this tutorial, we will show how to read and write multi-extension FITS (MEF) files. This means understanding the usage of the following service classes:</p>
<ul>
<li><code><a class="el" href="classEuclid_1_1Fits_1_1MefFile.html" title="Multi-Extension FITS file reader-writer.">MefFile</a></code> at file level,</li>
<li><code><a class="el" href="classEuclid_1_1Fits_1_1ImageHdu.html" title="Image HDU reader-writer.">ImageHdu</a></code> and <code><a class="el" href="classEuclid_1_1Fits_1_1BintableHdu.html" title="Binary table HDU reader-writer.">BintableHdu</a></code> at HDU level,</li>
<li><code><a class="el" href="classEuclid_1_1Fits_1_1ImageRaster.html" title="Reader-writer for the image data unit.">ImageRaster</a></code> and <code><a class="el" href="classEuclid_1_1Fits_1_1BintableColumns.html" title="Column-wise reader-writer for the binary table data unit.">BintableColumns</a></code> at data unit level;</li>
</ul>
<p >as well as <code><a class="el" href="structEuclid_1_1Fits_1_1Record.html" title="Keyword-value pair with optional unit and comment.">Record</a></code>, <code><a class="el" href="classEuclid_1_1Fits_1_1Raster.html" title="Data of a n-dimensional image (2D by default).">Raster</a></code> and <code><a class="el" href="classEuclid_1_1Fits_1_1Column.html" title="Binary table column data and metadata.">Column</a></code> data classes.</p>
<p >We strongly recommend reading first <a class="el" href="group__primer.html">What's a FITS file?</a>, even if you're familiar with the FITS format, because it introduces <code>EleFits</code>-specific wording.</p>
<p >At the end of the tutorial, you will be able to create a MEF file from scratch with unlimited number of various extensions, and to read the metadata and data back!</p>
<p >The tutorial is built together with an example program: <a class="el" href="EleFitsTutorial_8cpp-example.html">EleFitsTutorial.cpp</a>. We've embedded the calls to the logger in the code snippets below, so that you can easily map the execution log to the following explanations. You can already run the program and watch the resulting file:</p>
<div class="fragment"><div class="line">EleFitsTutorial --output tuto.fits</div>
<div class="line">fv tuto.fits</div>
</div><!-- fragment --><p >We'll first discover the data classes, then use them to create a MEF file, and finally read the file and values back.</p>
<dl class="section see"><dt>See also</dt><dd>To go further, at the end of each section, a link points to the reference page for the introduced topic.</dd></dl>
<h1><a class="anchor" id="tuto-setup"></a>
Setup</h1>
<p >First things first, we have to declare the dependency to EleFits and to use the right headers and namespaces. For the first part, head to the <a class="el" href="md_INSTALL.html">Installation and configuration guide</a>. For the headers and namespace, here's the only thing you'll have to do:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;EleFits/MefFile.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>Euclid;</div>
<div class="line"><span class="comment">// EleFits API is in the Euclid::Fits namespace.</span></div>
<div class="line"><span class="comment">// We could have be using namespace Euclid::Fits instead,</span></div>
<div class="line"><span class="comment">// but things would have been less obvious in the snippets.</span></div>
</div><!-- fragment --><h1><a class="anchor" id="tuto-data-classes"></a>
Data classes</h1>
<p >Data classes are the classes which hold the pieces of data read from and written to a FITS file. There are three main classes:</p>
<ul>
<li><code><a class="el" href="structEuclid_1_1Fits_1_1Record.html" title="Keyword-value pair with optional unit and comment.">Record</a></code> for header units,</li>
<li><code><a class="el" href="classEuclid_1_1Fits_1_1Raster.html" title="Data of a n-dimensional image (2D by default).">Raster</a></code> for data units of image HDUs,</li>
<li><code><a class="el" href="classEuclid_1_1Fits_1_1Column.html" title="Binary table column data and metadata.">Column</a></code> for data units of binary table HDUs.</li>
</ul>
<h2><a class="anchor" id="tuto-record"></a>
Record</h2>
<p >A keyword record as defined in the FITS standard is a triplet of keyword, value and optional comment rendered in the file as: </p><div class="fragment"><div class="line">KEYWORD = VALUE / comment</div>
</div><!-- fragment --><p >A unit can be included in the comment as follows: </p><div class="fragment"><div class="line">KEYWORD = VALUE / [unit] comment</div>
</div><!-- fragment --><p >The value can be a Boolean, an integer, real or complex number, or a string.</p>
<p ><code><a class="el" href="structEuclid_1_1Fits_1_1Record.html" title="Keyword-value pair with optional unit and comment.">Record</a></code> is a simple template class which merely stores those fields. For the purpose of the tutorial, we define a structure to hold our records:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>TutoRecords {</div>
<div class="line">  <a class="code hl_struct" href="structEuclid_1_1Fits_1_1Record.html">Fits::Record&lt;std::string&gt;</a> string_record;</div>
<div class="line">  <a class="code hl_struct" href="structEuclid_1_1Fits_1_1Record.html">Fits::Record&lt;int&gt;</a> int_record;</div>
<div class="line">  <a class="code hl_struct" href="structEuclid_1_1Fits_1_1Record.html">Fits::Record&lt;float&gt;</a> float_record;</div>
<div class="line">  <a class="code hl_struct" href="structEuclid_1_1Fits_1_1Record.html">Fits::Record&lt;std::complex&lt;double&gt;</a>&gt; complex_record;</div>
<div class="line">};</div>
<div class="ttc" id="astructEuclid_1_1Fits_1_1Record_html"><div class="ttname"><a href="structEuclid_1_1Fits_1_1Record.html">Euclid::Fits::Record</a></div><div class="ttdoc">Keyword-value pair with optional unit and comment.</div><div class="ttdef"><b>Definition:</b> Record.h:101</div></div>
</div><!-- fragment --><p >Here's a how they can be built:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">/* Create a record with unit and comment */</span></div>
<div class="line"> </div>
<div class="line">  <a class="code hl_struct" href="structEuclid_1_1Fits_1_1Record.html">Fits::Record&lt;std::string&gt;</a> string_record(<span class="stringliteral">&quot;STRING&quot;</span>, <span class="stringliteral">&quot;VALUE&quot;</span>, <span class="stringliteral">&quot;unit&quot;</span>, <span class="stringliteral">&quot;comment&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Create a record with keyword and value only */</span></div>
<div class="line"> </div>
<div class="line">  <a class="code hl_struct" href="structEuclid_1_1Fits_1_1Record.html">Fits::Record&lt;int&gt;</a> int_record(<span class="stringliteral">&quot;INT&quot;</span>, 0);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Create a record from an initialization list */</span></div>
<div class="line"> </div>
<div class="line">  <a class="code hl_struct" href="structEuclid_1_1Fits_1_1Record.html">Fits::Record&lt;float&gt;</a> float_record {<span class="stringliteral">&quot;FLOAT&quot;</span>, 3.14F, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;A piece of Pi&quot;</span>};</div>
<div class="line">  <span class="comment">// This is often used as a shortcut to create records as function parameters.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Generate a random record */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> complex_record = Fits::Test::generate_random_record&lt;std::complex&lt;double&gt;&gt;(<span class="stringliteral">&quot;COMPLEX&quot;</span>);</div>
<div class="line"> </div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__header__data__classes.html">Header data classes</a></dd></dl>
<h2><a class="anchor" id="tuto-raster"></a>
Raster</h2>
<p >Images in FITS are <em>n</em>-dimensional arrays. <code><a class="el" href="classEuclid_1_1Fits_1_1Raster.html" title="Data of a n-dimensional image (2D by default).">Raster</a></code> is a class which represents this kind of data and provides constant time pixel accessors. Template arguments are the pixel type and number of axes. There are two kinds of rasters:</p>
<ul>
<li><code>VecRaster</code> owns the data as an <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></code>;</li>
<li><code>PtrRaster</code> points to the data owned by another class, as a raw pointer (be careful not to destroy the data while the raster is alive).</li>
</ul>
<p >The rasters of this tutorial are stored in a dedicated structure:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>TutoRasters {</div>
<div class="line">  <a class="code hl_class" href="classEuclid_1_1Fits_1_1Raster.html">Fits::VecRaster&lt;std::int16_t, 2&gt;</a> int16_raster2d;</div>
<div class="line">  <a class="code hl_class" href="classEuclid_1_1Fits_1_1Raster.html">Fits::VecRaster&lt;std::int32_t, 3&gt;</a> int32_raster3d;</div>
<div class="line">  <a class="code hl_class" href="classEuclid_1_1Fits_1_1Raster.html">Fits::VecRaster&lt;std::int64_t, 4&gt;</a> int64_raster4d;</div>
<div class="line">};</div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1Raster_html"><div class="ttname"><a href="classEuclid_1_1Fits_1_1Raster.html">Euclid::Fits::Raster</a></div><div class="ttdoc">Data of a n-dimensional image (2D by default).</div><div class="ttdef"><b>Definition:</b> Raster.h:149</div></div>
</div><!-- fragment --><p >Again, let's show an example of how to create rasters:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">/* Initialize and later fill a raster */</span></div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classEuclid_1_1Fits_1_1Raster.html">Fits::VecRaster&lt;std::int16_t, 2&gt;</a> int16_raster2d({4, 3});</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; position : int16_raster2d.domain()) {</div>
<div class="line">    int16_raster2d[position] = position[0] + position[1];</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// This demonstrates the iteration over positions;</span></div>
<div class="line">  <span class="comment">// It is possible to use two nested loops instead.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Create a raster from a vector */</span></div>
<div class="line"> </div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;std::int32_t&gt;</a> int32_vec(16 * 9 * 3, 0);</div>
<div class="line">  <span class="comment">// ... do what you have to do with the vector, and then move it to the raster ...</span></div>
<div class="line">  <a class="code hl_class" href="classEuclid_1_1Fits_1_1Raster.html">Fits::VecRaster&lt;std::int32_t, 3&gt;</a> int32_raster3d({16, 9, 3}, <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/utility/move.html">std::move</a>(int32_vec));</div>
<div class="line">  <span class="comment">// Instead of moving a vector, it&#39;s also possible to work with</span></div>
<div class="line">  <span class="comment">// a raw pointer with the PtrRaster class.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Generate a random raster */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> int64_raster4d = <a class="code hl_class" href="classEuclid_1_1Fits_1_1Test_1_1RandomRaster.html">Fits::Test::RandomRaster&lt;std::int64_t, 4&gt;</a>({17, 9, 3, 24});</div>
<div class="line"> </div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1Test_1_1RandomRaster_html"><div class="ttname"><a href="classEuclid_1_1Fits_1_1Test_1_1RandomRaster.html">Euclid::Fits::Test::RandomRaster</a></div><div class="ttdoc">A random Raster of given type and shape.</div><div class="ttdef"><b>Definition:</b> TestRaster.h:54</div></div>
<div class="ttc" id="amove_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/utility/move.html">std::move</a></div><div class="ttdeci">T move(T... args)</div></div>
<div class="ttc" id="avector_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__image__data__classes.html">Image data classes</a></dd></dl>
<h2><a class="anchor" id="tuto-column"></a>
Column</h2>
<p >A binary table is made of columns which can be either scalar (each cell contains a value) or vector (each cell contains several values). In the latter case, the number of values per cell is named repeat count.</p>
<p >For string columns, the repeat count must be greater than the longest string value.</p>
<p >A <code><a class="el" href="classEuclid_1_1Fits_1_1Column.html" title="Binary table column data and metadata.">Column</a></code> is a simple structure which holds the column name, repeat count (=1 for scalar columns, &gt;1 for vector columns), unit, and owns or references some data, respectively as a <code>VecColumn</code> or as a <code>PtrColumn</code>.</p>
<p >The following structure stores the tutorial columns:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>TutoColumns {</div>
<div class="line">  <a class="code hl_class" href="classEuclid_1_1Fits_1_1Column.html">Fits::VecColumn&lt;std::string&gt;</a> string_column;</div>
<div class="line">  <a class="code hl_class" href="classEuclid_1_1Fits_1_1Column.html">Fits::VecColumn&lt;std::int32_t&gt;</a> int32_column;</div>
<div class="line">  <a class="code hl_class" href="classEuclid_1_1Fits_1_1Column.html">Fits::VecColumn&lt;float&gt;</a> float_column;</div>
<div class="line">};</div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1Column_html"><div class="ttname"><a href="classEuclid_1_1Fits_1_1Column.html">Euclid::Fits::Column</a></div><div class="ttdoc">Binary table column data and metadata.</div><div class="ttdef"><b>Definition:</b> Column.h:69</div></div>
</div><!-- fragment --><p >Here's a set of examples on how create them:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">/* Initialize and later fill a column */</span></div>
<div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classEuclid_1_1Fits_1_1Column.html">Fits::VecColumn&lt;std::string&gt;</a> string_column({<span class="stringliteral">&quot;STRING&quot;</span>, <span class="stringliteral">&quot;unit&quot;</span>, 3}, 100);</div>
<div class="line">  <span class="comment">// String columns must be wide-enough to hold each character.</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">long</span> i = 0; i &lt; string_column.row_count(); ++i) {</div>
<div class="line">    string_column(i) = <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/string/basic_string/to_string.html">std::to_string</a>(i);</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// operator() takes two parameters: the row index, and repeat index (=0 by default)</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Create a column from a vector */</span></div>
<div class="line"> </div>
<div class="line">  <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;std::int32_t&gt;</a> int32_vec(100);</div>
<div class="line">  <span class="comment">// ... do what you have to do with the vector, and then move it to the column ...</span></div>
<div class="line">  <a class="code hl_class" href="classEuclid_1_1Fits_1_1Column.html">Fits::VecColumn&lt;std::int32_t&gt;</a> int32_column({<span class="stringliteral">&quot;INT32&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, 1}, <a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/utility/move.html">std::move</a>(int32_vec));</div>
<div class="line">  <span class="comment">// Analogously to rasters, columns can be managed with the lightweight PtrColumn classe.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Generate a random column */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> float_column = <a class="code hl_class" href="classEuclid_1_1Fits_1_1Test_1_1RandomVectorColumn.html">Fits::Test::RandomVectorColumn&lt;float&gt;</a>(8, 100);</div>
<div class="line"> </div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1Test_1_1RandomVectorColumn_html"><div class="ttname"><a href="classEuclid_1_1Fits_1_1Test_1_1RandomVectorColumn.html">Euclid::Fits::Test::RandomVectorColumn</a></div><div class="ttdoc">A small vector column of given type.</div><div class="ttdef"><b>Definition:</b> TestColumn.h:172</div></div>
<div class="ttc" id="ato_string_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/string/basic_string/to_string.html">std::to_string</a></div><div class="ttdeci">T to_string(T... args)</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__bintable__data__classes.html">Binary table data classes</a></dd></dl>
<h1><a class="anchor" id="tuto-file"></a>
Open (and close) a MEF file</h1>
<p >Now that we have learned about the data classes, we can move to the service classes, or handlers. The first thing we can do is to create a new file.</p>
<p >The <code><a class="el" href="classEuclid_1_1Fits_1_1MefFile.html" title="Multi-Extension FITS file reader-writer.">MefFile</a></code> class represents multi-extension FITS (MEF) files. It extends the <code><a class="el" href="classEuclid_1_1Fits_1_1FitsFile.html" title="FITS file reader-writer.">FitsFile</a></code> class, which is also the base class of <code><a class="el" href="classEuclid_1_1Fits_1_1SifFile.html" title="Single image FITS file handler.">SifFile</a></code> for single-image FITS (SIF) files.</p>
<p >Creating (or opening) a file is simply done with the constructor of <code><a class="el" href="classEuclid_1_1Fits_1_1MefFile.html" title="Multi-Extension FITS file reader-writer.">MefFile</a></code> (or <code><a class="el" href="classEuclid_1_1Fits_1_1SifFile.html" title="Single image FITS file handler.">SifFile</a></code> for SIF files!):</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classEuclid_1_1Fits_1_1MefFile.html">Fits::MefFile</a> f(filename, <a class="code hl_enumvalue" href="namespaceEuclid_1_1Fits_a031770da453a180e21dcbef5cf5aeab6.html#a031770da453a180e21dcbef5cf5aeab6a686e697538050e4664636337cc3b834f">Fits::FileMode::Create</a>);</div>
<div class="line"> </div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1MefFile_html"><div class="ttname"><a href="classEuclid_1_1Fits_1_1MefFile.html">Euclid::Fits::MefFile</a></div><div class="ttdoc">Multi-Extension FITS file reader-writer.</div><div class="ttdef"><b>Definition:</b> MefFile.h:84</div></div>
<div class="ttc" id="anamespaceEuclid_1_1Fits_a031770da453a180e21dcbef5cf5aeab6_html_a031770da453a180e21dcbef5cf5aeab6a686e697538050e4664636337cc3b834f"><div class="ttname"><a href="namespaceEuclid_1_1Fits_a031770da453a180e21dcbef5cf5aeab6.html#a031770da453a180e21dcbef5cf5aeab6a686e697538050e4664636337cc3b834f">Euclid::Fits::FileMode::Create</a></div><div class="ttdeci">@ Create</div><div class="ttdoc">Create a new file (overwrite forbidden)</div></div>
</div><!-- fragment --><p >A newly created FITS file consists in an empty Primary, which can then be accessed and modified, but is never created by hand.</p>
<p >The mode parameter controls the access rights on the file. For example, an existing file can be opened with read-only mode:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <a class="code hl_class" href="classEuclid_1_1Fits_1_1MefFile.html">Fits::MefFile</a> f(filename, <a class="code hl_enumvalue" href="namespaceEuclid_1_1Fits_a031770da453a180e21dcbef5cf5aeab6.html#a031770da453a180e21dcbef5cf5aeab6a7a1a5f3e79fdc91edf2f5ead9d66abb4">Fits::FileMode::Read</a>);</div>
<div class="line"> </div>
<div class="ttc" id="anamespaceEuclid_1_1Fits_a031770da453a180e21dcbef5cf5aeab6_html_a031770da453a180e21dcbef5cf5aeab6a7a1a5f3e79fdc91edf2f5ead9d66abb4"><div class="ttname"><a href="namespaceEuclid_1_1Fits_a031770da453a180e21dcbef5cf5aeab6.html#a031770da453a180e21dcbef5cf5aeab6a7a1a5f3e79fdc91edf2f5ead9d66abb4">Euclid::Fits::FileMode::Read</a></div><div class="ttdeci">@ Read</div><div class="ttdoc">Open an existing file with read-only permission.</div></div>
</div><!-- fragment --><p >The file is closed when the destructor of <code><a class="el" href="classEuclid_1_1Fits_1_1MefFile.html" title="Multi-Extension FITS file reader-writer.">MefFile</a></code> is called (although a <code><a class="el" href="classEuclid_1_1Fits_1_1FitsFile_a47feccb1873356363e4d0e302bc3822c.html#a47feccb1873356363e4d0e302bc3822c" title="Close the file.">FitsFile::close()</a></code> method is provided for convenience).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__file__handlers.html">File handlers</a></dd></dl>
<h1><a class="anchor" id="tuto-write"></a>
Write a MEF file</h1>
<h2><a class="anchor" id="tuto-write-ext"></a>
Create extensions</h2>
<p ><code><a class="el" href="classEuclid_1_1Fits_1_1MefFile.html" title="Multi-Extension FITS file reader-writer.">MefFile</a></code> provides services to create and access extensions. Conceptually, <code><a class="el" href="classEuclid_1_1Fits_1_1MefFile.html" title="Multi-Extension FITS file reader-writer.">MefFile</a></code> is a <code><a class="el" href="classEuclid_1_1Fits_1_1FitsFile.html" title="FITS file reader-writer.">FitsFile</a></code> with a vector of HDUs (in contrast, <code><a class="el" href="classEuclid_1_1Fits_1_1SifFile.html" title="Single image FITS file handler.">SifFile</a></code> is a <code><a class="el" href="classEuclid_1_1Fits_1_1FitsFile.html" title="FITS file reader-writer.">FitsFile</a></code> with a single HDU).</p>
<p >HDUs are represented by two classes:</p>
<ul>
<li><code><a class="el" href="classEuclid_1_1Fits_1_1ImageHdu.html" title="Image HDU reader-writer.">ImageHdu</a></code> to access image HDUs,</li>
<li><code><a class="el" href="classEuclid_1_1Fits_1_1BintableHdu.html" title="Binary table HDU reader-writer.">BintableHdu</a></code> to access binary table HDUs.</li>
</ul>
<p >Both derive from parent class <code><a class="el" href="classEuclid_1_1Fits_1_1Hdu.html" title="Base class for ImageHdu and BintableHdu.">Hdu</a></code>.</p>
<p >To sum up, a <code><a class="el" href="classEuclid_1_1Fits_1_1MefFile.html" title="Multi-Extension FITS file reader-writer.">MefFile</a></code> is a vector of <code><a class="el" href="classEuclid_1_1Fits_1_1Hdu.html" title="Base class for ImageHdu and BintableHdu.">Hdu</a></code>s, which can be a mix of <code><a class="el" href="classEuclid_1_1Fits_1_1ImageHdu.html" title="Image HDU reader-writer.">ImageHdu</a></code>s and <code><a class="el" href="classEuclid_1_1Fits_1_1BintableHdu.html" title="Binary table HDU reader-writer.">BintableHdu</a></code>s.</p>
<p >There are two kinds of services in <code><a class="el" href="classEuclid_1_1Fits_1_1MefFile.html" title="Multi-Extension FITS file reader-writer.">MefFile</a></code> for creating extensions: They can be either initialized with header only or assigned directly with data. Here's an example of creating image HDUs:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">/* Fill the header and data units */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; image1 = f.append_image(<span class="stringliteral">&quot;IMAGE1&quot;</span>, {}, rasters.int32_raster3d);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Fill the header only (for now) */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; image2 = f.append_null_image&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int16_t</a>&gt;(<span class="stringliteral">&quot;IMAGE2&quot;</span>, {}, rasters.int16_raster2d.shape());</div>
<div class="line"> </div>
<div class="ttc" id="ainteger_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/types/integer.html">std::int16_t</a></div></div>
</div><!-- fragment --><p >And here's one of creating binary table HDUs:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">/* Fill the header and data units */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; table1 =</div>
<div class="line">      f.append_bintable(<span class="stringliteral">&quot;TABLE1&quot;</span>, {}, columns.string_column, columns.int32_column, columns.float_column);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Fill the header unit only (for now) */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; table2 = f.append_bintable_header(</div>
<div class="line">      <span class="stringliteral">&quot;TABLE2&quot;</span>,</div>
<div class="line">      {},</div>
<div class="line">      columns.string_column.info(),</div>
<div class="line">      columns.int32_column.info(),</div>
<div class="line">      columns.float_column.info());</div>
<div class="line"> </div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__file__handlers.html" title="Access and create files and HDUs.">File handlers</a></dd></dl>
<h2><a class="anchor" id="tuto-write-record"></a>
Write records</h2>
<p >Records are read and written through a <code><a class="el" href="classEuclid_1_1Fits_1_1Header.html" title="Reader-writer for the header unit.">Header</a></code> object, which is accessible from an <code><a class="el" href="classEuclid_1_1Fits_1_1ImageHdu.html" title="Image HDU reader-writer.">ImageHdu</a></code> or a <code><a class="el" href="classEuclid_1_1Fits_1_1BintableHdu.html" title="Binary table HDU reader-writer.">BintableHdu</a></code> as <code>header()</code>. They can be written and updated one-by-one or by sequences.</p>
<p >An optional template parameter controls the write policy, e.g. what to do if the given keyword already exists. By default, a record is created if the keyword doesn't exists, or updated if the keyword already exists.</p>
<p ><a class="el" href="structEuclid_1_1Fits_1_1Record.html" title="Keyword-value pair with optional unit and comment.">Record</a> writing functions have different overloards to allow calling them in different ways. Here are a few examples:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">/* Write a single record */</span></div>
<div class="line"> </div>
<div class="line">  h.write(records.string_record);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Write several records */</span></div>
<div class="line"> </div>
<div class="line">  h.write_n(records.int_record, records.float_record, records.complex_record);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Update using initialization lists */</span></div>
<div class="line"> </div>
<div class="line">  h.write_n&lt;<a class="code hl_enumvalue" href="group__header__handlers_ga9d89dadc7eae9423d082ce4bc9bfea5a.html#gga9d89dadc7eae9423d082ce4bc9bfea5aa939daf024a952aa749333024de0cedc5">Fits::RecordMode::UpdateExisting</a>&gt;(</div>
<div class="line">      <a class="code hl_struct" href="structEuclid_1_1Fits_1_1Record.html">Fits::Record&lt;int&gt;</a>(<span class="stringliteral">&quot;INT&quot;</span>, 1),</div>
<div class="line">      <a class="code hl_struct" href="structEuclid_1_1Fits_1_1Record.html">Fits::Record&lt;float&gt;</a>(<span class="stringliteral">&quot;FLOAT&quot;</span>, 3.14159F, <span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;A larger piece of Pi&quot;</span>),</div>
<div class="line">      <a class="code hl_struct" href="structEuclid_1_1Fits_1_1Record.html">Fits::Record&lt;std::complex&lt;double&gt;</a>&gt;(<span class="stringliteral">&quot;COMPLEX&quot;</span>, {180., 90.}));</div>
<div class="line"> </div>
<div class="ttc" id="agroup__header__handlers_ga9d89dadc7eae9423d082ce4bc9bfea5a_html_gga9d89dadc7eae9423d082ce4bc9bfea5aa939daf024a952aa749333024de0cedc5"><div class="ttname"><a href="group__header__handlers_ga9d89dadc7eae9423d082ce4bc9bfea5a.html#gga9d89dadc7eae9423d082ce4bc9bfea5aa939daf024a952aa749333024de0cedc5">Euclid::Fits::RecordMode::UpdateExisting</a></div><div class="ttdeci">@ UpdateExisting</div><div class="ttdoc">Modify a record, throw KeywordNotFoundError if keyword doesn't exist.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__header__handlers.html" title="Read and write header units.">Header unit handlers</a></dd></dl>
<h2><a class="anchor" id="tuto-write-image"></a>
Write image data</h2>
<p >Remember that we have left <code>IMAGE2</code> extension without data? Filling it is done through the <code><a class="el" href="classEuclid_1_1Fits_1_1ImageRaster.html" title="Reader-writer for the image data unit.">ImageRaster</a></code> class, accessed as <code><a class="el" href="classEuclid_1_1Fits_1_1ImageHdu_add08fe361b9dbee4dcb5a46644bbcca1.html#add08fe361b9dbee4dcb5a46644bbcca1" title="Access the data unit to read and write the raster.">ImageHdu::raster()</a></code>. For example, here is how to write all the pixels at once:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  image2.raster().write(rasters.int16_raster2d);</div>
<div class="line"> </div>
</div><!-- fragment --><p >Many more options are available to write data region-wise. They are described in details in <a class="el" href="group__image__handlers.html">Image data unit handlers</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__image__handlers.html" title="Read and write image data units.">Image data unit handlers</a></dd></dl>
<h2><a class="anchor" id="tuto-write-bintable"></a>
Write binary table data</h2>
<p >Analogously to <code><a class="el" href="classEuclid_1_1Fits_1_1ImageRaster.html" title="Reader-writer for the image data unit.">ImageRaster</a></code> for image HDUs, <code><a class="el" href="classEuclid_1_1Fits_1_1BintableColumns.html" title="Column-wise reader-writer for the binary table data unit.">BintableColumns</a></code> provides read/write services for the data unit of the binary table extension.</p>
<p >As the name implies, data is stored, read and written column-wise, as opposed to the row-major ordering of the FITS file. This is to avoid working with very complex structures like tuples with holes, and rather rely on <code><a class="el" href="classEuclid_1_1Fits_1_1Column.html" title="Binary table column data and metadata.">Column</a></code>, <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></code>, arrays... Yet, this also means that I/Os <em>could</em> be very inefficient! To workaround this, several columns can be written (and read) at a time. In this case, I/Os are internally performed chunk-wise, using some buffer, and performances drammatically improve.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">/* Write a single column */</span></div>
<div class="line"> </div>
<div class="line">  table2.columns().write(columns.string_column);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Write several columns */</span></div>
<div class="line"> </div>
<div class="line">  table2.columns().write_n(columns.int32_column, columns.float_column);</div>
<div class="line"> </div>
</div><!-- fragment --><p >Like for image HDUs, it is possible to write the data unit only partially, e.g. to append rows, using richer methods of <code><a class="el" href="classEuclid_1_1Fits_1_1BintableColumns.html" title="Column-wise reader-writer for the binary table data unit.">BintableColumns</a></code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__bintable__handlers.html" title="Read and write binary table data units.">Binary table data unit handlers</a></dd></dl>
<h1><a class="anchor" id="tuto-read"></a>
Read a MEF file</h1>
<h2><a class="anchor" id="tuto-access-hdu"></a>
Access HDUs</h2>
<p >HDUs can be accessed with a set of methods, templated with the type of HDU: <code><a class="el" href="classEuclid_1_1Fits_1_1BintableHdu.html" title="Binary table HDU reader-writer.">BintableHdu</a></code>, <code><a class="el" href="classEuclid_1_1Fits_1_1ImageHdu.html" title="Image HDU reader-writer.">ImageHdu</a></code>, or <code><a class="el" href="classEuclid_1_1Fits_1_1Hdu.html" title="Base class for ImageHdu and BintableHdu.">Hdu</a></code>. For metadata work, we don't need to know the type of HDU: whether this is an image or binary table HDU has no impact, and a <code><a class="el" href="classEuclid_1_1Fits_1_1Hdu.html" title="Base class for ImageHdu and BintableHdu.">Hdu</a></code> will be returned by default.</p>
<p >HDUs are accessed either by their name (first HDU whose name matches argument is returned) or by their index, and a shortcut is provided for the primary HDU (which has index 0):</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">/* Access the Primary HDU */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; primary = f.primary();</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> primary_index = primary.index();</div>
<div class="line">  <span class="comment">// Indices are 0-based.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Access an HDU by its index */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; image2 = f.access&lt;<a class="code hl_class" href="classEuclid_1_1Fits_1_1ImageHdu.html">Fits::ImageHdu</a>&gt;(2);</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> image_name = image2.<a class="code hl_function" href="classEuclid_1_1Fits_1_1Hdu.html#ac971ec99e55366ade2f32d9a28f9940a">read_name</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Access an HDU by its name */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; table1 = f.<a class="code hl_functionRef" href="http://en.cppreference.com/w/cpp/string/basic_string/find.html">find</a>&lt;<a class="code hl_class" href="classEuclid_1_1Fits_1_1BintableHdu.html">Fits::BintableHdu</a>&gt;(<span class="stringliteral">&quot;TABLE1&quot;</span>);</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> table_index = table1.<a class="code hl_function" href="classEuclid_1_1Fits_1_1Hdu.html#a48d9700bc3f8c008f48c2d67e5c52aac">index</a>();</div>
<div class="line">  <span class="comment">// If several HDUs have the same name, the first one is returned.</span></div>
<div class="line"> </div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1BintableHdu_html"><div class="ttname"><a href="classEuclid_1_1Fits_1_1BintableHdu.html">Euclid::Fits::BintableHdu</a></div><div class="ttdoc">Binary table HDU reader-writer.</div><div class="ttdef"><b>Definition:</b> BintableHdu.h:21</div></div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1Hdu_html_a48d9700bc3f8c008f48c2d67e5c52aac"><div class="ttname"><a href="classEuclid_1_1Fits_1_1Hdu.html#a48d9700bc3f8c008f48c2d67e5c52aac">Euclid::Fits::Hdu::index</a></div><div class="ttdeci">long index() const</div><div class="ttdoc">Get the 0-based index of the HDU.</div></div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1Hdu_html_ac971ec99e55366ade2f32d9a28f9940a"><div class="ttname"><a href="classEuclid_1_1Fits_1_1Hdu.html#ac971ec99e55366ade2f32d9a28f9940a">Euclid::Fits::Hdu::read_name</a></div><div class="ttdeci">std::string read_name() const</div><div class="ttdoc">Read the extension name.</div></div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1ImageHdu_html"><div class="ttname"><a href="classEuclid_1_1Fits_1_1ImageHdu.html">Euclid::Fits::ImageHdu</a></div><div class="ttdoc">Image HDU reader-writer.</div><div class="ttdef"><b>Definition:</b> ImageHdu.h:45</div></div>
<div class="ttc" id="afind_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/string/basic_string/find.html">std::string::find</a></div><div class="ttdeci">T find(T... args)</div></div>
</div><!-- fragment --><p >You've probably noticed that we use references to <em>constant</em> HDU handlers. Indeed, HDU handlers are not modified by reading and writing services, only the <code><a class="el" href="classEuclid_1_1Fits_1_1MefFile.html" title="Multi-Extension FITS file reader-writer.">MefFile</a></code> is. Actually, HDU-level and data unit-level handlers are very light classes which aim at providing a clear interface.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__file__handlers.html" title="Access and create files and HDUs.">File handlers</a></dd></dl>
<h2><a class="anchor" id="tuto-read-record"></a>
Parse records</h2>
<p ><code><a class="el" href="structEuclid_1_1Fits_1_1Record.html" title="Keyword-value pair with optional unit and comment.">Record</a></code>s are parsed using <code><a class="el" href="classEuclid_1_1Fits_1_1Header.html" title="Reader-writer for the header unit.">Header</a></code> services. Like for writing, you can parse several records at once:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">/* Read a single record */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> int_record = h.parse&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;INT&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Records can be sliced as their value for immediate use:</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span> int_value = h.parse&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;INT&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Read several records */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> some_records = h.parse_n(</div>
<div class="line">      Fits::as&lt;std::string&gt;(<span class="stringliteral">&quot;STRING&quot;</span>),</div>
<div class="line">      Fits::as&lt;int&gt;(<span class="stringliteral">&quot;INT&quot;</span>),</div>
<div class="line">      Fits::as&lt;float&gt;(<span class="stringliteral">&quot;FLOAT&quot;</span>),</div>
<div class="line">      Fits::as&lt;std::complex&lt;double&gt;&gt;(<span class="stringliteral">&quot;COMPLEX&quot;</span>));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; third_record = std::get&lt;2&gt;(some_records);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Read as VariantValue */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> variant_records = h.parse_n&lt;&gt;({<span class="stringliteral">&quot;INT&quot;</span>, <span class="stringliteral">&quot;COMPLEX&quot;</span>});</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> complex_record = variant_records.as&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex&lt;double&gt;</a>&gt;(<span class="stringliteral">&quot;COMPLEX&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Read as a user-defined structure */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> tuto_records = h.parse_struct&lt;TutoRecords&gt;(</div>
<div class="line">      Fits::as&lt;std::string&gt;(<span class="stringliteral">&quot;STRING&quot;</span>),</div>
<div class="line">      Fits::as&lt;int&gt;(<span class="stringliteral">&quot;INT&quot;</span>),</div>
<div class="line">      Fits::as&lt;float&gt;(<span class="stringliteral">&quot;FLOAT&quot;</span>),</div>
<div class="line">      Fits::as&lt;std::complex&lt;double&gt;&gt;(<span class="stringliteral">&quot;COMPLEX&quot;</span>));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; string_record = tuto_records.string_record;</div>
<div class="line"> </div>
<div class="ttc" id="acomplex_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a></div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__header__handlers.html" title="Read and write header units.">Header unit handlers</a></dd></dl>
<h2><a class="anchor" id="tuto-read-image"></a>
Read image data</h2>
<p >Like for writing, reading images is ensured by <code><a class="el" href="classEuclid_1_1Fits_1_1ImageRaster.html" title="Reader-writer for the image data unit.">ImageRaster</a></code>. A <code>VecRaster</code> is generally instantiated, and pixel values can be accessed with the subscript operator <code>[]</code>:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> image = du.read&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int16_t</a>, 2&gt;();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; first_pixel = image[{0, 0}];</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; last_pixel = image.at({-1, -1});</div>
<div class="line">  <span class="comment">// `operator[]` performs no bound checking, while `at` does and enables backward indexing.</span></div>
<div class="line"> </div>
</div><!-- fragment --><p >Again, regions can be read.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__image__handlers.html" title="Read and write image data units.">Image data unit handlers</a></dd></dl>
<h2><a class="anchor" id="tuto-read-bintable"></a>
Read binary table data</h2>
<p ><a class="el" href="classEuclid_1_1Fits_1_1Column.html" title="Binary table column data and metadata.">Column</a> reading is provided by <code><a class="el" href="classEuclid_1_1Fits_1_1BintableColumns.html" title="Column-wise reader-writer for the binary table data unit.">BintableColumns</a></code>. Columns are generally read as <code>VecColumn</code>s, values of which are accessed with the call operator <code>()</code>:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  <span class="comment">/* Read a single column */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> vector_column = du.read&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;VECTOR&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Read several columns by their name */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> by_name = du.read_n(Fits::as&lt;std::string&gt;(<span class="stringliteral">&quot;STRING&quot;</span>), Fits::as&lt;std::int32_t&gt;(<span class="stringliteral">&quot;INT32&quot;</span>));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; string_column = std::get&lt;0&gt;(by_name);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Read several columns by their index */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> by_index = du.read_n(Fits::as&lt;std::string&gt;(0), Fits::as&lt;std::int32_t&gt;(1));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; int_column = std::get&lt;1&gt;(by_index);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">/* Use values */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; first_string = string_column(0);</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; first_int = int_column(0);</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; last_float = vector_column.at(-1, -1);</div>
<div class="line">  <span class="comment">// There is no operator[]() for columns, because vector columns require 2 indices (row and repeat).</span></div>
<div class="line">  <span class="comment">// operator()() performs no bound checking, while at() does and enables backward indexing.</span></div>
<div class="line"> </div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__bintable__handlers.html" title="Read and write binary table data units.">Binary table data unit handlers</a> </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<hr class="footer" />
<address class="footer"><small>
    © Copyright 2019-2022 CNES and contributors (for the Euclid Science Ground Segment).
    <br>
    The EleFits documentation is licensed under a
    <a rel="license" href="md_LICENSE.html">LGPL-3.0-or-later</a> license.
    <br>
    It is generated by <a href="https://www.doxygen.org/index.html">Doxygen</a> 1.9.5
    with a theme adapted from <a href="https://github.com/jothepro/doxygen-awesome-css">Doxygen Awesome</a>
    and using <a href="https://github.com/tholman/github-corners">GitHub Corners</a>.
    Thank you all!
  </small></address>
</body>
</html>