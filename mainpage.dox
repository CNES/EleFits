namespace Euclid {
namespace FitsIO {

/**

\mainpage Project Overview


\section purpose Purpose and Scope

The purpose of the library is to provide a user-friendly and efficient API to read and write Fits files.

The library merely consists in a thin CFitsIO wrapper:
There is no intelligence inside.
The actual reading and writing are delegated to CFitsIO,
with as few indirections as possible to minimize overhead.
As compared to CFitsIO API, the main benefits are:

- No more raw pointers for a safe memory management;
- No more type codes but template classes which handle architecture specifics for you;
- No more error codes but proper exception handling;
- Structures dedicated to data storage instead of zillions of unorganized and redundent variables;
- A lightweight class hierarchy to represent the actual Fits organization (e.g. extensions, records, columns...)
instead of the all-in-one and flat fitsfile structure;
- A concise and clear API instead of the cluttered and verbose one of CFitsIO;
- A comprehensive testing and validation code.

Simplicity comes at the cost of completeness,
and EL_FitsIO misses CFitsIO features that we found less important or too complex,
like ASCII table extensions, streaming or compression.


\section api End-user API

The end-user API is made of two kinds of classes:

- data classes store raw data;
- service classes allow reading and writing the data.

Here is the (simplified) class diagram of the end-user API:

\image html doc/diagrams/out/FitsFile.png

\subsection data-classes Data classes

Records, image rasters and bintable columns are implemented as light structures to abstract from CFitsIO raw pointers:

- Record is made of a name, value, unit and comment;
- Raster represents a _n_-dimensional array with constant-time pixel access;
- Column stores metadata (name, unit, width) and values.

\subsection service-classes Read-write classes

Service classes are organized according to the Fits format:

- MefFile, the root object, provides file-level services (open, close, access HDUs);
- RecordHdu only handles records;
- ImageHdu and BintableHdu, respectively the image and bintable HDU reader-writers, additionally provide access to the raster and columns.


\section modules Modules

\subsection module-cfitsiowrapper EL_CfitsioWrapper is an internal CFitsIO wrapper

A set of CFitsIO functions are wrapped in C++ functions to secure memory usage, ease type handling through templates, and throw exceptions instead of returning error codes.
Yet, this API is not meant for end-users: it exposes the fitsfile* type and is still a bit verbose and cumbersome.

\subsection module-fitsdata EL_FitsData contains basic data-storage structures

Records, image rasters and bintable columns are implemented as light structures to abstract from CFitsIO raw pointers:

- Record is made of a name, value, unit and comment;
- Raster represents a _n_-dimensional array with constant-time pixel access;
- Column stores metadata (name, unit, width) and values.

\subsection module-fitsfile EL_FitsFile is the end-user API

It provides set of read-write services in dedicated classes, namely:

- MefFile, the root object, which provides file-level services (open, close, access HDUs);
- RecordHdu, the basic HDU reader-writer, which only handles records;
- ImageHdu and BintableHdu, respectively the image and bintable HDU reader-writers, which additionally provide access to the raster and columns.

\subsection module-examples EL_FitsIO_Examples provides examples!

Among others, the module compares CFitsIO, EL_CfitsioWrapper and EL_FitsFile implementations of the same program,
which demonstrates the reading and writing of records, images and bintables.

\subsection module-validation EL_FitsIO_Validation contains validation executables

Generators allow creating dummy Fits files from scratch.
The performances of the library are compared to those of CFitsIO.

*/

}
}
