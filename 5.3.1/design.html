<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.9.5" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EleFits: Software design</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <div id="top">
      <!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr style="height: 56px;">
              <td id="projectlogo"><a href="https://cnes.github.io/EleFits/"><img alt="Logo"
                    src="elefits_notext.png" /></a></td>
              <td id="projectalign" style="padding-left: 0.5em;">
                <div id="projectname">EleFits
                  <span id="projectnumber">&#160;5.3.1</span>
                </div>
                <div id="projectbrief">A modern C++ API on top of CFITSIO</div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
      <!-- GitHub corner -->
      <a href="https://github.com/CNES/EleFits" class="github-corner" aria-label="View source on GitHub"><svg
          viewBox="0 0 250 250" aria-hidden="true">
          <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
          <path
            d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
            fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
          <path
            d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
            fill="currentColor" class="octo-body"></path>
        </svg></a>
      <!-- GitHub corner --><!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Software design </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#design-purpose">Purpose and scope</a></li>
<li class="level1"><a href="#design-overview">Library organization</a><ul><li class="level2"><a href="#design-layers">Layers</a></li>
<li class="level2"><a href="#design-namespace">Namespaces</a></li>
<li class="level2"><a href="#design-modules">Modules</a></li>
<li class="level2"><a href="#design-sources">Source files</a></li>
</ul>
</li>
<li class="level1"><a href="#design-types">Type codes</a><ul><li class="level2"><a href="#design-types-overview">Overview</a></li>
<li class="level2"><a href="#design-types-codes">Type code handling</a></li>
<li class="level2"><a href="#design-types-string">Specific types: strings</a></li>
<li class="level2"><a href="#design-types-any">Specific types: variant values</a></li>
</ul>
</li>
<li class="level1"><a href="#design-variadic">Variadic templates</a></li>
<li class="level1"><a href="#design-data-classes">Data classes</a></li>
<li class="level1"><a href="#design-handlers">File handlers</a></li>
<li class="level1"><a href="#design-hdu-handlers">HDU handlers</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="design-purpose"></a>
Purpose and scope</h1>
<p >The purpose of this page is to describe the internal implementation of EleFits. Usage of the API is described in the main pages of this documentation. When implementation and usage are titghly coupled, links are provided to get the user point-of-view.</p>
<h1><a class="anchor" id="design-overview"></a>
Library organization</h1>
<h2><a class="anchor" id="design-layers"></a>
Layers</h2>
<p >The package is split in two layers:</p>
<ul>
<li>A high-level object-oriented layer (namespace FITS, see below) which aims at handling FITS files and their contents with an as-simple-as-possible modern API:<ul>
<li>The file structure is mapped to a class tree (file, HDUs, records and co. are represented by dedicated classes),</li>
<li>Data classes represent the data contents of the file,</li>
<li>Service classes provide access to each node of the file structure;</li>
</ul>
</li>
<li>A low-level procedural layer (namespace Cfitsio, see below) which consists in C++ wrapper functions of selected CFITSIO functions, not intended to end-users:<ul>
<li>C arrays are wrapped with aforementioned data classes,</li>
<li>The use of raw pointers is limited to <code>fitsfile*</code>, which is itself wrapped in the service classes,</li>
<li>Templates wrap the CFITSIO type codes,</li>
<li>Exceptions wrap the CFITSIO error codes.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="design-namespace"></a>
Namespaces</h2>
<p >The API is organized in namespaces as follows:</p>
<ul>
<li><code>Euclid</code> is the top level namespace, which contains everything;</li>
<li><code>Cfitsio</code> corresponds to the low-level layer module:<ul>
<li>It is organized in thematic namespaces like <code>Cfitsio::FileAccess</code> or <code>Cfitsio::ImageIo</code>;</li>
</ul>
</li>
<li><code><a class="el" href="namespaceEuclid_1_1Fits.html" title="Wrapper classes to read and write FITS file contents.">Fits</a></code> is the end-user namespace:<ul>
<li>Data classes and service classes are implemented in it,</li>
<li><code><a class="el" href="namespaceEuclid_1_1Fits_1_1Test.html" title="Test-related classes and functions.">Fits::Test</a></code> contains test helper classes and functions like fixtures;</li>
</ul>
</li>
<li>Whatever the level, <code>Internal</code> namespaces contain implementation details, not displayed to the end-user.</li>
</ul>
<h2><a class="anchor" id="design-modules"></a>
Modules</h2>
<p >This translates into the following set of modules:</p>
<ul>
<li><code>EleFitsData</code> contains basic <b>data-storage structures</b>: Records, binary table columns and image rasters are implemented as light structures to abstract from CFITSIO (void) raw pointers; See <a class="el" href="group__data__classes.html">Data classes</a> for more details on their API and usage.</li>
<li><code>EleCfitsioWrapper</code> is the low-level layer: The set of CFITSIO functions are wrapped in C++ functions to secure memory usage, ease type handling through templates, and throw exceptions instead of returning error codes; Yet, this API is <b>not meant for end-users</b>: it exposes the <code>fitsfile*</code> type and is still a bit verbose and cumbersome.</li>
<li><code>EleFits</code> exposes the end-user API: It provides set of <b>read-write services</b> in dedicated classes; See <a class="el" href="group__handlers.html">File and HDU handlers</a> for more details.</li>
<li><code>EleFitsExamples</code> provides <b>examples</b>! Among others, the module compares CFITSIO, <code>EleCfitsioWrapper</code> and <code>EleFits</code> implementations of the same program, which demonstrates the reading and writing of records, images and binary tables with the three APIs; Of course, this is also where the tutorial is implemented.</li>
<li><code>EleFitsValidation</code> contains <b>validation executables</b>:<ul>
<li>Generator programs allow creating dummy FITS files from scratch;</li>
<li>The performances of EleFits are compared to those of CFITSIO;</li>
<li>A validation script checks that all of the provided programs run smoothly.</li>
</ul>
</li>
</ul>
<p >Auxiliary classes, like exceptions, which are useful to both <code>EleCfitsioWrapper</code> and <code>EleFits</code> are implemented in <code>EleFitsData</code>.</p>
<p >The general organization of the free functions, data classes and service classes in modules is illustrated below in the form of a class diagram.</p>
<div class="image">
<img src="ClassOverview.png" alt=""/>
</div>
<h2><a class="anchor" id="design-sources"></a>
Source files</h2>
<p >Inside each module, the source files are organized as follows:</p>
<ul>
<li>The declarations are in files with <code>.h</code> extension in a folder named after the module;</li>
<li>The inline (inc. template) definitions are in files with <code>.hpp</code> extension in a subfolder <code>impl</code> of the header folder;</li>
<li>The other library definitions are in files with <code>.cpp</code> extension in the folder <code>src/lib</code>;</li>
<li>Tests are implemented in the folder <code>tests/src</code>, in files with <code>_test</code> suffix and <code>.cpp</code> extension;</li>
<li>The programs are implemented in <code>.cpp</code> files in the folder <code>src/program</code>.</li>
</ul>
<h1><a class="anchor" id="design-types"></a>
Type codes</h1>
<h2><a class="anchor" id="design-types-overview"></a>
Overview</h2>
<p >Simple things first:</p><ul>
<li>Indices and lengths are implemented as <code>long</code>s instead of <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">std::size_t</a></code>s (see <a class="el" href="group__types.html">On types</a> rationale).</li>
<li>Strings are generally handled as <code><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a></code>; additionally, a few shortcuts with <code>const char *</code> are provided; In the latter case, a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a></code> version is still provided.</li>
</ul>
<p >As for the binary parts of FITS files (image and binary table data), the mapping is not straightforward. CFITSIO functions are not consistent with this respect: half of them work with built-in types (e.g. CFITSIO type code <code>TSHORT</code> corresponds to <code>short</code>) and the other half with fixed types (e.g. CFITSIO type code <code>SHORT_IMG</code> corresponds to <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int16_t</a></code>). Check the <a class="el" href="type_map.html">CFITSIO type mapping table</a> for more details. This makes the user responsible of knowing the underlying architecture, or to spend runtime in conversions at each reading and writing operation.</p>
<h2><a class="anchor" id="design-types-codes"></a>
Type code handling</h2>
<p >One of the main purposes of EleFits is to abstract from type codes, and to provide homogeneous template functions. This is implemented as type traits in class <code>Cfitsio::TypeCode</code>, which provides one method per column of the <a class="el" href="type_map.html">CFITSIO type mapping table</a>. Template specialization are made with built-in types or fixed types depending on what the CFITSIO functions expect. For example, <code>TSHORT</code> is <code>TypeCode&lt;short&gt;::for_image()</code> and <code>SHORT_IMG</code> is <code>TypeCode&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int16_t</a>&gt;::<a class="el" href="namespaceEuclid_1_1Fits.html#a964744896874b05e00d5637efd1fc3a6" title="Get the BITPIX value of a given type.">bitpix()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>Internally, CFITSIO does the opposite when working with built-in types: it detects the length of those types and selects the appropriate fixed type. Therefore, a possible improvement would be to bypass top-level CFITSIO functions, and avoid casting fixed types to built-ins and back. Yet, the runtime benefit is expected to be minimal for such a costly development effort (see benchmark results).</dd></dl>
<h2><a class="anchor" id="design-types-string"></a>
Specific types: strings</h2>
<p >As stated above, strings are represented with <code><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a></code>, while CFITSIO is using <code>const char *</code> or even <code>char *</code>. Most of the template functions are therefore specialized for <code><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a></code>. It is thus required to specialize reading and writing methods for strings. Moreover, strings are treated very differently from other types in binary table columns: they are considered by CFITSIO like scalar columns with a repeat count greater than one. Therefore, <code><a class="el" href="classEuclid_1_1Fits_1_1Column.html" title="Binary table column data and metadata.">Fits::Column</a></code> methods are also specialized.</p>
<p >One classical transform needed to interface with CFITSIO is to convert a sequence of strings (e.g. a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&gt;</code>) into a <code>char **</code>. This must be done carefully to keep the memory clean. A class dedicated to the transform is implemented: <code>CStrArray</code>, which can be built from a sequence of strings and has a getter which returns a <code>char **</code>.</p>
<h2><a class="anchor" id="design-types-any"></a>
Specific types: variant values</h2>
<p >Another specific type is <code>VariantValue</code>, which is an alias for <code>boost::any</code> as of today (see note below). It was added to the library to handle large sets of heterogeneous records. It is obviously necessary to provide read and write functions for this type, and they have to work with any underlying value type. This is implemented as runtime switches in read and write functions.</p>
<p >In addition, <code><a class="el" href="structEuclid_1_1Fits_1_1Record.html" title="Keyword-value pair with optional unit and comment.">Record</a>&lt;VariantValue&gt;</code> can be cast to <code><a class="el" href="structEuclid_1_1Fits_1_1Record.html" title="Keyword-value pair with optional unit and comment.">Record</a>&lt;T&gt;</code> if <code>T</code> is compatible with the underlying <code>VariantValue</code> value type. This cast is more complex than a mere <code>boost::any_cast</code> because the size of an integer record cannot be known at compile time. For example, 666 is read as a <code>short</code>, while 1,000,000 is read as an <code>int</code> or <code>long</code>. Since there is no way for the user to know the value and therefore the deduced type of a record, the casting service should allow to request an <code>int</code> when a <code>short</code> was read. Method <code><a class="el" href="structEuclid_1_1Fits_1_1Record_ae3fbb22622132e6ca734fa02e77dfcbf.html#ae3fbb22622132e6ca734fa02e77dfcbf" title="Helper function to cast Record value types. Valid casts are:">Record::cast()</a></code> is in charge of handling the various cases.</p>
<dl class="section note"><dt>Note</dt><dd>A welcome improvement would be to switch from <code>boost::any</code> to <code>boost::variant</code> or <code>std::variant</code> (C++17). This would allow relying on compile-time dispatch (visitor pattern) instead of runtime dispatch (switches). This is the role of <a class="el" href="structEuclid_1_1Fits_1_1Record_ae3fbb22622132e6ca734fa02e77dfcbf.html#ae3fbb22622132e6ca734fa02e77dfcbf" title="Helper function to cast Record value types. Valid casts are:">Fits::Record::cast</a>.</dd></dl>
<h1><a class="anchor" id="design-variadic"></a>
Variadic templates</h1>
<p >Reading and writing collections of heterogeneous objects, like columns of different types, requires using variadic templates (or abstraction classes like <code>VariantValue</code> which cost too much for thousands of values).</p>
<p >Variatic template design patterns to be documented:</p><ul>
<li>recursive implementation</li>
<li>partial specialization</li>
<li>return parameters</li>
<li>packs vs. tuples</li>
<li>TSeq vs. variadic</li>
<li>use of forward and forward_as_tuple</li>
<li><a class="el" href="namespaceEuclid_1_1Fits.html#abd6da346e9bb7bb8fc569e08fea42455" title="Apply a void-returning function to each element of a sequence.">seq_foreach()</a> and <a class="el" href="namespaceEuclid_1_1Fits.html#a915891a1c2ce671f82752392355134e7" title="Apply a transform to each element of a sequence and create a user-defined struct from the results.">seq_transform()</a></li>
</ul>
<h1><a class="anchor" id="design-data-classes"></a>
Data classes</h1>
<p >Data classes are <code><a class="el" href="structEuclid_1_1Fits_1_1Record.html" title="Keyword-value pair with optional unit and comment.">Record</a></code>, <code><a class="el" href="classEuclid_1_1Fits_1_1Raster.html" title="Data of a n-dimensional image (2D by default).">Raster</a></code>, <code><a class="el" href="classEuclid_1_1Fits_1_1Column.html" title="Binary table column data and metadata.">Column</a></code> and their child or helper classes (e.g. <code><a class="el" href="structEuclid_1_1Fits_1_1ColumnInfo.html" title="Column informations, i.e. name, unit, field shape and value type.">ColumnInfo</a></code>).</p>
<p >To give as much freedom as possible to the user, <code><a class="el" href="classEuclid_1_1Fits_1_1Raster.html" title="Data of a n-dimensional image (2D by default).">Raster</a></code> and <code><a class="el" href="classEuclid_1_1Fits_1_1Column.html" title="Binary table column data and metadata.">Column</a></code> are interfaces with as few requirements as possible. Implementations are provided to allow users working without writing their own implementations, although this is a possibility. <code><a class="el" href="classEuclid_1_1Fits_1_1Raster.html" title="Data of a n-dimensional image (2D by default).">Raster</a></code> and <code><a class="el" href="classEuclid_1_1Fits_1_1Column.html" title="Binary table column data and metadata.">Column</a></code> are implemented as analogously as possible. Theycome with two flavors:</p><ul>
<li><code>PtrRaster</code> and <code>PtrColumn</code> do not own the raw data array: they just now a pointer to it;</li>
<li><code>VecRaster</code> and <code>VecColumn</code> own the data: such objects are returned by read services.</li>
</ul>
<h1><a class="anchor" id="design-handlers"></a>
File handlers</h1>
<p >File operations to be documented.</p>
<p >Vector of HDUs to be documented.</p>
<p >Nested classes are generally avoided, in order to simplify name resolution. The passkey idiom is preferred, to make constructors private.</p>
<h1><a class="anchor" id="design-hdu-handlers"></a>
HDU handlers</h1>
<p >To be documented:</p><ul>
<li>Handling of HDUs through vector of pointers</li>
<li>HDU factory, inc. passkey idiom</li>
<li>Access through const references </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<hr class="footer" />
<address class="footer"><small>
    © Copyright 2019-2022 CNES and contributors (for the Euclid Science Ground Segment).
    <br>
    The EleFits documentation is licensed under a
    <a rel="license" href="md_LICENSE.html">LGPL-3.0-or-later</a> license.
    <br>
    It is generated by <a href="https://www.doxygen.org/index.html">Doxygen</a> 1.9.5
    with a theme adapted from <a href="https://github.com/jothepro/doxygen-awesome-css">Doxygen Awesome</a>
    and using <a href="https://github.com/tholman/github-corners">GitHub Corners</a>.
    Thank you all!
  </small></address>
</body>
</html>