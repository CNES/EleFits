<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.9.2" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EleFits: On the API design</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
    <div id="top">
      <!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr style="height: 56px;">
              <td id="projectlogo"><a href="https://cnes.github.io/EleFits/"><img alt="Logo"
                    src="elefits_notext.png" /></a></td>
              <td id="projectalign" style="padding-left: 0.5em;">
                <div id="projectname">EleFits
                  <span id="projectnumber">&#160;5.0.0</span>
                </div>
                <div id="projectbrief">A modern C++ API on top of CFITSIO</div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
      <!-- GitHub corner -->
      <a href="https://github.com/CNES/EleFits" class="github-corner" aria-label="View source on GitHub"><svg
          viewBox="0 0 250 250" aria-hidden="true">
          <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
          <path
            d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
            fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
          <path
            d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
            fill="currentColor" class="octo-body"></path>
        </svg></a>
      <!-- GitHub corner --><!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle"><div class="title">On the API design<div class="ingroups"><a class="el" href="group__guidelines.html">Development guidelines</a></div></div></div>
</div><!--header-->
<div class="contents">
<p >Understanding the design helps using EleFits better. </p>
<h1><a class="anchor" id="api_design-history"></a>
A journey to the API design</h1>
<p >The main reason why we have started implementing EleFits is to make usage safer wrt. CFITSIO and CCfits. This means improving type safety, memory management, and also safety of use in the sense of preventing API usage mistakes. This comes with the simplification of the parameters (no pointers, structured groups of parameters...) and the reduction of their number and of the amount of duplication.</p>
<p >Let's consider the following use case: In the fourth extension of some file "catalog.fits", read columns "ID" and "RADEC" as vectors of <code>string</code> and <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt;double&gt;</code>, respectively. By the way, get the name of the extension.</p>
<p >An object-based API following the CFITSIO approach (one single class does everything) could be something like this:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classEuclid_1_1Fits_1_1FitsFile.html">FitsFile</a> f(<span class="stringliteral">&quot;catalog.fits&quot;</span>, FileMode::READ);</div>
<div class="line">f.access(4);</div>
<div class="line"><span class="keyword">auto</span> name = f.readHduName();</div>
<div class="line"><span class="keyword">auto</span> <span class="keywordtype">id</span> = f.readColumn&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&gt;(<span class="stringliteral">&quot;ID&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> radec = f.readColumn&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex&lt;double&gt;</a>&gt;(<span class="stringliteral">&quot;RADEC&quot;</span>);</div>
<div class="ttc" id="abasic_string_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a></div></div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1FitsFile_html"><div class="ttname"><a href="classEuclid_1_1Fits_1_1FitsFile.html">Euclid::Fits::FitsFile</a></div><div class="ttdoc">FITS file reader-writer.</div><div class="ttdef"><b>Definition:</b> FitsFile.h:85</div></div>
<div class="ttc" id="acomplex_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a></div></div>
</div><!-- fragment --><p >Here, <code><a class="el" href="classEuclid_1_1Fits_1_1FitsFile.html" title="FITS file reader-writer.">FitsFile</a></code> is responsible for everything: accessing and creating the HDUs, reading and writing the header units as well as the image and binary table data units. The code is simple to read but to reach the number of features EleFits provides, several hundreds of methods would be in <code><a class="el" href="classEuclid_1_1Fits_1_1FitsFile.html" title="FITS file reader-writer.">FitsFile</a></code>.</p>
<p >A CCfits-like approach would go down to the level of HDUs but not header units and data units:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classEuclid_1_1Fits_1_1FitsFile.html">FitsFile</a> f(<span class="stringliteral">&quot;catalog.fits&quot;</span>, FileMode::READ);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; hdu = f.access(4); <span class="comment">// Returns an Hdu</span></div>
<div class="line"><span class="keyword">auto</span> name = hdu.readName();</div>
<div class="line"><span class="keyword">auto</span> <span class="keywordtype">id</span> = hdu.readColumn&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&gt;(<span class="stringliteral">&quot;ID&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> radec = hdu.readColumn&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex&lt;double&gt;</a>&gt;(<span class="stringliteral">&quot;RADEC&quot;</span>);</div>
</div><!-- fragment --><p >We have decoupled HDU access and creation on one hand (in <code><a class="el" href="classEuclid_1_1Fits_1_1FitsFile.html" title="FITS file reader-writer.">FitsFile</a></code>) and reading and writing on the other hand (in <code><a class="el" href="classEuclid_1_1Fits_1_1Hdu.html" title="Base class for ImageHdu and BintableHdu.">Hdu</a></code>), which makes the classes smaller, but there are still major issues: for example, methods to read image data can be called on <code>hdu</code> which represents a binary table extension. This can be easily mitigated by creating classes <code><a class="el" href="classEuclid_1_1Fits_1_1ImageHdu.html" title="Image HDU reader-writer.">ImageHdu</a></code> and <code><a class="el" href="classEuclid_1_1Fits_1_1BintableHdu.html" title="Binary table HDU reader-writer.">BintableHdu</a></code>.</p>
<p >To further reduce the coupling between header units and data units, classes have been introduced as follows:</p><ul>
<li><code><a class="el" href="classEuclid_1_1Fits_1_1ImageHdu.html" title="Image HDU reader-writer.">ImageHdu</a></code>s are made of a <code><a class="el" href="classEuclid_1_1Fits_1_1Header.html" title="Reader-writer for the header unit.">Header</a></code> and <code><a class="el" href="classEuclid_1_1Fits_1_1ImageRaster.html" title="Reader-writer for the image data unit.">ImageRaster</a></code>;</li>
<li><code><a class="el" href="classEuclid_1_1Fits_1_1BintableHdu.html" title="Binary table HDU reader-writer.">BintableHdu</a></code>s are made of a <code><a class="el" href="classEuclid_1_1Fits_1_1Header.html" title="Reader-writer for the header unit.">Header</a></code> and <code><a class="el" href="classEuclid_1_1Fits_1_1BintableColumns.html" title="Column-wise reader-writer for the binary table data unit.">BintableColumns</a></code>;</li>
<li><code><a class="el" href="classEuclid_1_1Fits_1_1Hdu.html" title="Base class for ImageHdu and BintableHdu.">Hdu</a></code> is the parent class of <code><a class="el" href="classEuclid_1_1Fits_1_1ImageHdu.html" title="Image HDU reader-writer.">ImageHdu</a></code> and <code><a class="el" href="classEuclid_1_1Fits_1_1BintableHdu.html" title="Binary table HDU reader-writer.">BintableHdu</a></code>, which can store the name and index of the HDU.</li>
</ul>
<div class="fragment"><div class="line"><a class="code hl_class" href="classEuclid_1_1Fits_1_1FitsFile.html">FitsFile</a> f(<span class="stringliteral">&quot;catalog.fits&quot;</span>, FileMode::READ);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; hdu = f.access&lt;<a class="code hl_class" href="classEuclid_1_1Fits_1_1BintableHdu.html">BintableHdu</a>&gt;(4); <span class="comment">// Get a BintableHdu instead of an Hdu</span></div>
<div class="line"><span class="keyword">auto</span> name = hdu.<a class="code hl_function" href="classEuclid_1_1Fits_1_1Hdu.html#a6776ebef4fa628350e95f9378fe7a9cb">readName</a>(); <span class="comment">// From parent class Hdu</span></div>
<div class="line"><span class="keyword">auto</span> <span class="keywordtype">id</span> = hdu.columns().read&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&gt;(<span class="stringliteral">&quot;ID&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> radec = hdu.columns().read&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex&lt;double&gt;</a>&gt;(<span class="stringliteral">&quot;RADEC&quot;</span>);</div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1BintableHdu_html"><div class="ttname"><a href="classEuclid_1_1Fits_1_1BintableHdu.html">Euclid::Fits::BintableHdu</a></div><div class="ttdoc">Binary table HDU reader-writer.</div><div class="ttdef"><b>Definition:</b> BintableHdu.h:21</div></div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1Hdu_html_a6776ebef4fa628350e95f9378fe7a9cb"><div class="ttname"><a href="classEuclid_1_1Fits_1_1Hdu.html#a6776ebef4fa628350e95f9378fe7a9cb">Euclid::Fits::Hdu::readName</a></div><div class="ttdeci">std::string readName() const</div><div class="ttdoc">Read the extension name.</div></div>
</div><!-- fragment --><p >Last but not least, for performance, it is preferable to read several columns at the same time:</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classEuclid_1_1Fits_1_1FitsFile.html">FitsFile</a> f(<span class="stringliteral">&quot;catalog.fits&quot;</span>, FileMode::READ);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; hdu = f.access(4);</div>
<div class="line"><span class="keyword">auto</span> name = hdu.<a class="code hl_function" href="classEuclid_1_1Fits_1_1Hdu.html#a6776ebef4fa628350e95f9378fe7a9cb">readName</a>();</div>
<div class="line"><span class="keyword">auto</span> catalog = hdu.columns().readSeq&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex&lt;double&gt;</a>&gt;({<span class="stringliteral">&quot;ID&quot;</span>, <span class="stringliteral">&quot;RADEC&quot;</span>});</div>
</div><!-- fragment --><p >One issue remains with the above proposal. Imagine a more realistic use case where more columns should be read:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> catalog = hdu.columns().readSeq&lt;</div>
<div class="line">    <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex&lt;double&gt;</a>, double, float, double, float, <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int16_t</a>&gt;(</div>
<div class="line">        {<span class="stringliteral">&quot;ID&quot;</span>, <span class="stringliteral">&quot;RADEC&quot;</span>, <span class="stringliteral">&quot;Z&quot;</span>, <span class="stringliteral">&quot;FLUX&quot;</span>, <span class="stringliteral">&quot;SHAPE&quot;</span>, <span class="stringliteral">&quot;SPECTRUM&quot;</span>, <span class="stringliteral">&quot;THUMBNAIL&quot;</span>});</div>
<div class="ttc" id="ainteger_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/types/integer.html">std::int16_t</a></div></div>
</div><!-- fragment --><p >It is very easy to make mistakes in the order of the arguments. To solve this, we can manage to have each column data type written alongside its name:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> catalog = hdu.columns().readSeq(</div>
<div class="line">    as&lt;std::string&gt;(<span class="stringliteral">&quot;ID&quot;</span>),</div>
<div class="line">    as&lt;<a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex&lt;double&gt;</a>&gt;(<span class="stringliteral">&quot;RADEC&quot;</span>),</div>
<div class="line">    as&lt;double&gt;(<span class="stringliteral">&quot;Z&quot;</span>),</div>
<div class="line">    as&lt;float&gt;(<span class="stringliteral">&quot;FLUX&quot;</span>),</div>
<div class="line">    as&lt;double&gt;(<span class="stringliteral">&quot;SHAPE&quot;</span>),</div>
<div class="line">    as&lt;float&gt;(<span class="stringliteral">&quot;SPECTRUM&quot;</span>),</div>
<div class="line">    as&lt;std::int16_t&gt;(<span class="stringliteral">&quot;THUMBNAIL&quot;</span>));</div>
</div><!-- fragment --><p >We have introduced a new template class to store the type as the template parameter and the name as a member variable. This is the purpose of <code><a class="el" href="structEuclid_1_1Fits_1_1TypedKey.html" title="A light structure to bind a return type and a key, e.g. for reading records and columns.">TypedKey</a></code> in EleFits, which is instantiated with function <code><a class="el" href="structEuclid_1_1Fits_1_1TypedKey_a3f3bfa50b0881fbf7343089efb3d3249.html#a3f3bfa50b0881fbf7343089efb3d3249" title="Create a TypedKey where the key type is deduced from the parameter.">as()</a></code> for consiceness.</p>
<p >The above code snippet reads very fluently: To read a catalog which is the following sequence of columns:</p><ul>
<li>"ID" as <code>std::strings</code>s,</li>
<li>"RADEC" as <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>&lt;double&gt;</code>s,</li>
<li>"Z" as <code>double</code>s,</li>
<li>...</li>
</ul>
<h1><a class="anchor" id="api_design-cons"></a>
Drawbacks of API fluency</h1>
<p >The main drawback of fluent APIs is that they often involve many classes which should be seen as implementation details. For example, the above line can be decomposed as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> fileName = <span class="stringliteral">&quot;catalog.fits&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_enumeration" href="namespaceEuclid_1_1Fits_a031770da453a180e21dcbef5cf5aeab6.html#a031770da453a180e21dcbef5cf5aeab6">FileMode</a> mode = FileMode::READ;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">long</span> hduIndex = 4;</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> idName = <span class="stringliteral">&quot;ID&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> radecName = <span class="stringliteral">&quot;RADEC&quot;</span>;</div>
<div class="line"><span class="keyword">using</span> Id = <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>;</div>
<div class="line"><span class="keyword">using</span> Radec = <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex&lt;double&gt;</a>;</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_struct" href="structEuclid_1_1Fits_1_1TypedKey.html">TypedKey&lt;Id, std::string&gt;</a> idKey(idName);</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_struct" href="structEuclid_1_1Fits_1_1TypedKey.html">TypedKey&lt;Radec, std::string&gt;</a> radecKey(idName);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classEuclid_1_1Fits_1_1MefFile.html">MefFile</a> f(fileName, mode);</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classEuclid_1_1Fits_1_1BintableHdu.html">BintableHdu</a>&amp; hdu = f.access&lt;<a class="code hl_class" href="classEuclid_1_1Fits_1_1BintableHdu.html">BintableHdu</a>&gt;(hduIndex);</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="classEuclid_1_1Fits_1_1BintableColumns.html">BintableColumns</a>&amp; du = hdu.<a class="code hl_function" href="classEuclid_1_1Fits_1_1BintableHdu_a3a9219f697d816fd9826a435bd224897.html#a3a9219f697d816fd9826a435bd224897">columns</a>();</div>
<div class="line"><a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;VecColumn&lt;Id&gt;</a>, <a class="code hl_class" href="classEuclid_1_1Fits_1_1Column.html">VecColumn&lt;Radec&gt;</a>&gt; coords = du.readSeq(idKey, radecKey);</div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1BintableColumns_html"><div class="ttname"><a href="classEuclid_1_1Fits_1_1BintableColumns.html">Euclid::Fits::BintableColumns</a></div><div class="ttdoc">Column-wise reader-writer for the binary table data unit.</div><div class="ttdef"><b>Definition:</b> BintableColumns.h:77</div></div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1BintableHdu_a3a9219f697d816fd9826a435bd224897_html_a3a9219f697d816fd9826a435bd224897"><div class="ttname"><a href="classEuclid_1_1Fits_1_1BintableHdu_a3a9219f697d816fd9826a435bd224897.html#a3a9219f697d816fd9826a435bd224897">Euclid::Fits::BintableHdu::columns</a></div><div class="ttdeci">const BintableColumns &amp; columns() const</div><div class="ttdoc">Access the data unit column-wise.</div></div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1Column_html"><div class="ttname"><a href="classEuclid_1_1Fits_1_1Column.html">Euclid::Fits::Column</a></div><div class="ttdoc">Binary table column data and metadata.</div><div class="ttdef"><b>Definition:</b> Column.h:69</div></div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1MefFile_html"><div class="ttname"><a href="classEuclid_1_1Fits_1_1MefFile.html">Euclid::Fits::MefFile</a></div><div class="ttdoc">Multi-Extension FITS file reader-writer.</div><div class="ttdef"><b>Definition:</b> MefFile.h:72</div></div>
<div class="ttc" id="anamespaceEuclid_1_1Fits_a031770da453a180e21dcbef5cf5aeab6_html_a031770da453a180e21dcbef5cf5aeab6"><div class="ttname"><a href="namespaceEuclid_1_1Fits_a031770da453a180e21dcbef5cf5aeab6.html#a031770da453a180e21dcbef5cf5aeab6">Euclid::Fits::FileMode</a></div><div class="ttdeci">FileMode</div><div class="ttdoc">FITS file read/write permissions.</div><div class="ttdef"><b>Definition:</b> FitsFile.h:49</div></div>
<div class="ttc" id="astructEuclid_1_1Fits_1_1TypedKey_html"><div class="ttname"><a href="structEuclid_1_1Fits_1_1TypedKey.html">Euclid::Fits::TypedKey</a></div><div class="ttdoc">A light structure to bind a return type and a key, e.g. for reading records and columns.</div><div class="ttdef"><b>Definition:</b> DataUtils.h:78</div></div>
<div class="ttc" id="atuple_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a></div></div>
</div><!-- fragment --><p >Here we see how verbose the implementation can be for a rather simple example. There are 5 EleFits types involved: <code><a class="el" href="classEuclid_1_1Fits_1_1MefFile.html" title="Multi-Extension FITS file reader-writer.">MefFile</a></code>, <code><a class="el" href="classEuclid_1_1Fits_1_1BintableHdu.html" title="Binary table HDU reader-writer.">BintableHdu</a></code>, <code><a class="el" href="classEuclid_1_1Fits_1_1BintableColumns.html" title="Column-wise reader-writer for the binary table data unit.">BintableColumns</a></code>, <code><a class="el" href="structEuclid_1_1Fits_1_1TypedKey.html" title="A light structure to bind a return type and a key, e.g. for reading records and columns.">TypedKey</a></code>, <code>VecColumn</code>. Among them, 2 are meant for fluency, and should not be instantiated explicitely: <code><a class="el" href="classEuclid_1_1Fits_1_1BintableColumns.html" title="Column-wise reader-writer for the binary table data unit.">BintableColumns</a></code> and <code><a class="el" href="structEuclid_1_1Fits_1_1TypedKey.html" title="A light structure to bind a return type and a key, e.g. for reading records and columns.">TypedKey</a></code>.</p>
<p >For clearer code, the solution lies inbetween the two extreme code example given above. <code><a class="el" href="classEuclid_1_1Fits_1_1BintableColumns.html" title="Column-wise reader-writer for the binary table data unit.">BintableColumns</a></code> can be replaced with <code><a class="el" href="classEuclid_1_1Fits_1_1BintableHdu_a3a9219f697d816fd9826a435bd224897.html#a3a9219f697d816fd9826a435bd224897" title="Access the data unit column-wise.">BintableHdu::columns()</a></code> and <code><a class="el" href="structEuclid_1_1Fits_1_1TypedKey.html" title="A light structure to bind a return type and a key, e.g. for reading records and columns.">TypedKey</a></code> with <code><a class="el" href="structEuclid_1_1Fits_1_1TypedKey_a3f3bfa50b0881fbf7343089efb3d3249.html#a3f3bfa50b0881fbf7343089efb3d3249" title="Create a TypedKey where the key type is deduced from the parameter.">as()</a></code>. Also, <code>auto</code> should be favored over explicit return types. Finally, a more natural writing of the example is:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> fileName = <span class="stringliteral">&quot;catalog.fits&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">long</span> hduIndex = 4;</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> idName = <span class="stringliteral">&quot;ID&quot;</span>;</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> radecName = <span class="stringliteral">&quot;RADEC&quot;</span>;</div>
<div class="line"><span class="keyword">using</span> Id = <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>;</div>
<div class="line"><span class="keyword">using</span> Radec = <a class="code hl_classRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex&lt;double&gt;</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classEuclid_1_1Fits_1_1MefFile.html">MefFile</a> f(fileName, FileMode::READ);</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; hdu = f.access&lt;<a class="code hl_class" href="classEuclid_1_1Fits_1_1BintableHdu.html">BintableHdu</a>&gt;(hduIndex);</div>
<div class="line"><span class="keyword">auto</span> coords = hdu.<a class="code hl_function" href="classEuclid_1_1Fits_1_1BintableHdu_a3a9219f697d816fd9826a435bd224897.html#a3a9219f697d816fd9826a435bd224897">columns</a>().<a class="code hl_function" href="classEuclid_1_1Fits_1_1BintableColumns_a010f1580642ad98def74b68602c3540b.html#a010f1580642ad98def74b68602c3540b">readSeq</a>(as&lt;Id&gt;(idName), as&lt;Radec&gt;(radecName));</div>
<div class="ttc" id="aclassEuclid_1_1Fits_1_1BintableColumns_a010f1580642ad98def74b68602c3540b_html_a010f1580642ad98def74b68602c3540b"><div class="ttname"><a href="classEuclid_1_1Fits_1_1BintableColumns_a010f1580642ad98def74b68602c3540b.html#a010f1580642ad98def74b68602c3540b">Euclid::Fits::BintableColumns::readSeq</a></div><div class="ttdeci">std::tuple&lt; VecColumn&lt; Ts, 1 &gt;... &gt; readSeq(const TypedKey&lt; Ts, TKey &gt; &amp;... keys) const</div><div class="ttdoc">Read a tuple of columns with given names or indices.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="api_design-doc"></a>
How the documentation copes with fluency</h1>
<p >Although they are simple to read, large fluent APIs are hard to document, due to the relatively large amount of classes. Because it is not convenient to browse many class documentation pages when trying to perform such a simple operation, the documentation of EleFits is built around examples. For example, if you check the documentation of <code><a class="el" href="classEuclid_1_1Fits_1_1BintableColumns_a010f1580642ad98def74b68602c3540b.html#a010f1580642ad98def74b68602c3540b" title="Read a tuple of columns with given names or indices.">BintableColumns::readSeq()</a></code>, you will see that, although the parameters are of type <code><a class="el" href="structEuclid_1_1Fits_1_1TypedKey.html" title="A light structure to bind a return type and a key, e.g. for reading records and columns.">TypedKey</a></code>, the method documentation explains that they can be fed with a name or index and provides simple and more complex examples, so that the reader doesn't need to check the <code><a class="el" href="structEuclid_1_1Fits_1_1TypedKey.html" title="A light structure to bind a return type and a key, e.g. for reading records and columns.">TypedKey</a></code> documentation itself.</p>
<p >Additionally, the main documentation pages are not those of the namespaces or classes, but the <a href="modules.html">Module pages</a>, in which related classes are gathered. </p>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.2-->
<!-- start footer part -->
<hr class="footer" />
<address class="footer"><small>
    Â© Copyright 2019-2022 CNES and contributors (for the Euclid Science Ground Segment).
    <br>
    The EleFits documentation is licensed under a
    <a rel="license" href="md_LICENSE.html">LGPL-3.0-or-later</a> license.
    <br>
    It is generated by <a href="https://www.doxygen.org/index.html">Doxygen</a> 1.9.2
    with a theme adapted from <a href="https://github.com/jothepro/doxygen-awesome-css">Doxygen Awesome</a>
    and using <a href="https://github.com/tholman/github-corners">GitHub Corners</a>.
    Thank you all!
  </small></address>
</body>
</html>