namespace Euclid {
namespace Fits {
namespace Compression {

/**

\addtogroup image_compression


\tableofcontents


\section compression-intro External vs. Internal Compressions


FITS supports two compression approaches:

- External compression by GZIPing of the entire file.
  In this case, the whole uncompressed file is stored in memory.
  At read time, it is initially decompressed and everything then occurs in memory (or disk with swapping).
  At write time, the file is compressed in memory, and then written entirely to the file system at closure.
- Internal compression with any of the supported algorithms.
  This compression acts at Image Extension level: the Primary HDU and the Binary table Extensions cannot be compressed this way.
  When a compressed HDU is accessed, only the required region is decompressed/compressed on the fly.
  Therefore, memory usage is minimized.

Both compression approaches can be combined.


\section compression-external External Compression


External compression is transparent: if the filename ends with `.gz`, then external compression is enabled.
From the API point of view, no change is required wrt. uncompressed files.


\section compression-internal Internal Compression


\subsection compression-internal-principle Principle


Standard FITS files are made of HDUs which can be either images or tables.
Binary tables can contain variable-length columns (which are not publically supported by EleFits):
such columns can hold vector values of varying length.

Internally compressed Image HDUs are partitioned into regular non-overlapping boxes called tiles (typically, rows).
Each of the tiles is compressed with a given algorithm, and the compressed tile values are stored in a cell of a Binary table.
The compressed tiles have different sizes since the compression rate depends on the actual pixel values,
which is why variable-length columns are used.

In practice, this means that a compressed Image HDU is effectively stored as a Binary table HDU,
although with specific keywords stating that this is no classical table.
Most viewers and libraries (including EleFits) provide an Image HDU interface for them,
i.e. at reading, it is not necessary to know whether an Image is compressed or not.
For writing, compression must be explicitely enabled before creating the HDU,
but then classical write functions are used as if the HDU was not compressed.

Given that the Primary HDU is necessarily an Image HDU, it cannot be compressed.
Generally, if the Primary has to be internally compressed (e.g. for SIF files), then an extension is added after an empty Primary.
Therefore, even lossless compression may be non-idempotent:
indeed, decompressing such a file would result in a MEF file with an empty Primary and decompressed Extension corresponding to the input Primary,
instead of a single decompressed Primary.

\code
SifFile uncompressed("uncompressed.fits", FileMode::ReadOnly);

MerFile compressed("compressed.fits", FileMode::Create);
compressed.startCompressing(Compression::HCompress());
compressed.assignImage({}, uncompressed.raster().read<2, float>());

MefFile decompressed("decompressed.fits", FileMode::Create);
decompressed.assignImage({}, decompressed.as<ImageRaster>(1).read<2, float>());
\endcode


\subsection compression-internal-algos Algorithms and Parameters


EleFits, like CFITSIO, supports several compression algorithms.
They are implemented as independent data classes responsible for storing the parameters.
Let us first introduce briefly the various algorithms and parameters, before discussing the interfaces.

All internal compression algorithms act on data regions named tiles,
which are compressed and decompressed independently.
Tiles are represented by their common shape (edge tiles may be cropped).
Generally, the default tile is a row.
When the images to be compressed have a small width, such a tile might be too small.
In this case, using larger tiles is recommended.
For smallest images, the whole data can even be used.
When image processing is planned to be performed tile-wise (e.g. row-by-row),
then the compression tile should relate to the processing tile such that compression and processing tile borders match as often as possible.

Parameters can be set either globally for all tiles,
or tile-wise, in which case they are relative to the noise level in the tile.

By default, compression of integer-valued images is lossless,
while compression of floating point-valued images is lossy.
This is the consequence of quantization.
Quantization is a conversion from floating point to integer values, performed before the actual compression algorithm is run.
This is a first level of compression, where the least significant digits of a floating-point number are dropped.
Quantization can also be turned off to enable lossless compression.
On the other hand, integer-valued data can be quantized, by casting them as floating-point data,
making compression necessarily lossy.

Once this step has been performed, the quantized, integral values are effectively compressed losslessly by one of the supported algorithms:

- GZIP (class `Gzip`) is the classical file compression algorithm.
- Suffled GZIP (`ShuffledGzip`) first applies some byte reordering and generally shows a greater compression rate than GZIP.
- `Rice` is the de facto standard FITS compression algorithm:
  It is compatible with all data types and values and offers better performances than GZIP.
- PLIO (`Plio`) is designed for integer values, and more specifically bitmasks;
  Values higher than 2^24 cannot be compressed with this algorithm.
- `HCompress` is a somewhat more advanced algorithm, which may require more tuning than others,
  and explicitely targets 2D images.

@see R. L. White, P. Greenfield, W. Pence, D. Tody, R. Seaman.
_Tiled Image Convention for Storing Compressed Images in FITS Binary Tables._

TODO interface

*/

}
}
}
