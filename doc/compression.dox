namespace Euclid {
namespace Fits {

/**

\addtogroup image_compression


\tableofcontents


\section compression-intro External vs. Internal Compressions


FITS supports two compression approaches:

- External compression by GZIPing of the entire file.
  In this case, the whole uncompressed file is stored in memory.
  At read time, it is initially decompressed and everything then occurs in memory (or disk with swapping).
  At write time, the file is compressed in memory, and then written entirely to the file system at closure.
- Internal compression with any of the supported algorithms.
  This compression acts at Image Extension level: the Primary HDU and the Binary table Extensions cannot be compressed this way.
  When a compressed HDU is accessed, only the required region is decompressed/compressed on the fly.
  Therefore, memory usage is minimized.

Both compression approaches can be combined.


\section compression-external External Compression


External compression is transparent: if the filename ends with `.gz`, then external compression is enabled.
From the API point of view, no change is required wrt. uncompressed files.


\section compression-internal Internal Compression


\subsection compression-internal-principle Principle


Standard FITS files are made of HDUs which can be either images or tables.
Binary tables can contain variable-length columns (which are not publically supported by EleFits):
such columns can hold vector values of varying length.

Internally compressed Image HDUs are partitioned into regular non-overlapping boxes called tiles (typically, rows).
Each of the tiles is compressed with a given algorithm, and the compressed tile values are stored in a cell of a Binary table.
The compressed tiles have different sizes since the compression rate depends on the actual pixel values,
which is why variable-length columns are used.

In practice, this means that a compressed Image HDU is effectively stored as a Binary table HDU,
although with specific keywords stating that this is no classical table.
Most viewers and libraries (including EleFits) provide an Image HDU interface for them,
i.e. at reading, it is not necessary to know whether an Image is compressed or not.
For writing, compression must be explicitely enabled before creating the HDU,
but then classical write functions are used as if the HDU was not compressed.

Given that the Primary HDU is necessarily an Image HDU, it cannot be compressed.
Generally, if the Primary has to be internally compressed (e.g. for SIF files), then an extension is added after an empty Primary.
Therefore, even lossless compression may be non-idempotent:
indeed, decompressing such a file would result in a MEF file with an empty Primary and decompressed Extension corresponding to the input Primary,
instead of a single decompressed Primary.

\code
SifFile uncompressed("uncompressed.fits", FileMode::ReadOnly);

MerFile compressed("compressed.fits", FileMode::Create);
compressed.startCompressing(HCompress());
compressed.assignImage({}, uncompressed.raster().read<2, float>());

MefFile decompressed("decompressed.fits", FileMode::Create);
decompressed.assignImage({}, decompressed.as<ImageRaster>(1).read<2, float>());
\endcode


\subsection compression-internal-algos Algorithms and Parameters


EleFits, like CFITSIO, supports several compression algorithms.
They are implemented as independent data classes responsible for storing the parameters.
Let us first introduce briefly the various algorithms and parameters, before discussing the interfaces.

All internal compression algorithms act on data regions named tiles,
which are compressed and decompressed independently.
Tiles are represented by their common shape (edge tiles may be cropped).
Generally, the default tile is a row.
When the images to be compressed have a small width (say, less than a thousand pixels), such a tile might be too small.
In this case, using larger tiles is recommended.
For smallest images (a few thousands of pixels at most), the whole data can even be used.
When image processing is planned to be performed tile-wise (e.g. row-by-row),
then the compression tile should relate to the processing tile such that compression and processing tile borders match as often as possible.

As opposed to CFITSIO, by default, compression is lossless whatever the pixel type.
If one tries to use some lossless algorithm with incompatible data type (e.g. H-compress with `double`), an error is thrown. 
Lossy compression is available, for any pixel type, by enabling quantization.
Quantization is a conversion from floating point to integer values, performed before the actual compression algorithm is run.
This is a first level of compression, where the least significant digits of a floating-point number are dropped.
Quantization can be turned on for integral-valued data, too, in which case they are first cast as floating-point data.

Once this step has been performed, the quantized, integral values are effectively compressed losslessly by one of the supported algorithms:

- GZIP (class `Gzip`) is the classical file compression algorithm and can be applied without quantization.
- Suffled GZIP (`ShuffledGzip`) first applies some byte reordering and generally shows a greater compression rate than GZIP.
- `Rice` is the de facto standard FITS compression algorithm:
  It is lossy for floating point values and can be lossless for integer values;
  It generally offers better performances than GZIP.
- H-compress (`HCompress`) is a somewhat more advanced algorithm, which may require more tuning than others,
  and explicitely targets 2D images;
  It is lossless with integer values when both quantization and scaling are disabled.
- PLIO (`Plio`) is designed for integer values, and more specifically bitmasks;
  Values higher than 2^24 cannot be compressed with this algorithm;
  It is not recommended to use quantization with PLIO.

<table class="fieldtable">
<tr><th>Class<th>Integral data<th>Floating point data
<tr><td>`Gzip`<td>Lossless iff quantization is disabled.<td>Lossless iff quantization is disabled.
<tr><td>`ShuffledGzip`<td>Lossless iff quantization is disabled.<td>Lossless iff quantization is disabled.
<tr><td>`Rice`<td>Lossless iff quantization is disabled.<td>Lossy
<tr><td>`HCompress`<td>Lossless iff quantization and scaling are disabled.<td>Lossy
<tr><td>`Plio`<td>Lossless iff quantization is disabled.<td>Lossy
</table>

@see R. L. White, P. Greenfield, W. Pence, D. Tody, R. Seaman.
_Tiled Image Convention for Storing Compressed Images in FITS Binary Tables._


\subsection compression-interface Interface


As mentioned in the previous section, compression algorithms are represented by dedicated classes.
In addition, `NoCompression` can be used to disable internal compression.
All those classes implement the `Compression` interface.
Generic compression parameters are the tiling shape (as a `Position<-1>` object)
and quantization (as a `Compression::Quantization` object).
More details can be found in the classes and methods documentation (see list below).

Once the `Compression` instance is created, it must be passed to `MefFile::startCompressing()`.
From this point, newly created Image HDUs will automatically be compressed.
Note that it is not possible to convert an uncompressed Image HDU into a compressed one,
and compression must be activated before creating HDUs.
The compression algorithm or parameters can be changed for subsequent HDUs by calling again `MefFile::startCompressing()`.
Disabling compression can be done with `NoCompression` or by calling `MefFile::stopCompressing()`.

*/

}
}
