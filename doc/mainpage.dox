namespace Euclid {
namespace FitsIO {

/**

\mainpage Project Overview


\tableofcontents


\section purpose Purpose and scope


The purpose of the library is to provide a user-friendly and efficient API to read and write Fits files.

The library merely consists in a thin CFitsIO wrapper:
There is no intelligence inside.
The actual reading and writing are delegated to CFitsIO,
with as few indirections as possible to minimize overhead.
As compared to CFitsIO API, the main benefits are:

- No more raw pointers for a **safe memory management**;
- No more type codes but **template classes** which handle architecture specifics for you;
- No more error codes but proper **exception handling**;
- Structures dedicated to **data storage** instead of zillions of unorganized and redundent variables;
- A **lightweight class hierarchy** to represent the actual Fits organization (e.g. extensions, records, columns...)
instead of the all-in-one and flat `fitsfile` structure;
- A **concise and clear API** instead of the cluttered and verbose one of CFitsIO;
- A **comprehensive testing** and validation code.

Simplicity comes at the cost of completeness,
and EL_FitsIO misses:
- CFitsIO features that we found less important or too complex,
like ASCII table extensions, streaming or compression;
- Features already well implemented in other Euclid libraries,
like iterators covered by EL_CatalogLib;
- Features that we didn't have time to implement yet.

For a clear overview of what's there and what's missing, see \ref cfitsio-cov.


\section build Install and depend on EL_FitsIO

`EL_FitsIO` depends on `Elements`, a build framework based on CMake.
As such, `EL_FitsIO` can be used either from an Elements project or from a CMake project.

\subsection build-elements For an Elements project

An elements project is made of modules.
The project contains a root `CMakeLists.txt`, as well as each module.
For more information, please refer to the [`Elements` documentation](TODO).

Using the library means declaring the dependency to the `EL_FitsIO` project in the root `CMakeLists.txt`:

\verbatim
elements_project(MyProject X.X
    USE EL_FitsIO Y.Y)
\endverbatim

and to the `EL_FitsFile` module (for the end-user API) in the `CMakeLists.txt` of each module which requires `EL_FitsIO`:

\verbatim
elements_depends_on_subdirs(EL_FitsFile)

elements_add_executable(<program_name> src/program/<program_name>.cpp
    LINK_LIBRARIES ElementsKernel EL_FitsFile)

elements_add_library(<library_name> src/Lib/*.cpp
    LINK_LIBRARIES ElementsKernel EL_FitsFile
    INCLUDE_DIRS ElementsKernel EL_FitsFile
    PUBLIC_HEADERS <library_name>)
\endverbatim

\subsection build-cmake For a CMake project

First, install `Elements` with user-defined prefix (e.g. the standard `/usr`):

\verbatim
cd <root>/Elements
mkdir build
cd build
cmake -DCMAKE_INSTALL_PREFIX=<prefix> ..
sudo make install -j
\endverbatim

Then, install EL_FitsIO the same way:

\verbatim
cd <root>/EL_FitsIO
mkdir build
cd build
cmake -DCMAKE_INSTALL_PREFIX=<prefix> ..
sudo make install -j
\endverbatim

This will install the the set of libraries in `<prefix>/lib`, headers in `<prefix>/include`, and executables in `<prefix>/bin`.
The end-user library is named `EL_FitsFile`.
Here's a minimal `CMakeLists.txt` file to use it:

\verbatim
CMAKE_MINIMUM_REQUIRED(VERSION <version>)
project(<project_name>)
find_package(EL_FitsFile REQUIRED)
add_executable(<exe_name> <exe_source>)
target_link_libraries(<exe_name> EL_FitsFile)
\endverbatim

The `find_package` command expects parent folder of the file `FindEL_FitsFile.cmake` to be in the `CMAKE_MODULE_PATH`.
For now, it is located in the sources of `EL_FitsIO`, in `cmake/modules`.

Here's an example to configure a project:

\verbatim
cd <root>/<project_name>
mkdir build
cd build
cmake -DCMAKE_MODULE_PATH=<root>/EL_FitsIO/cmake/modules ..
\endverbatim


\section api End-user API overview (and tutorial)


The end-user API is made of two kinds of classes:

- \ref data-classes "Data classes" store raw data;
- \ref handlers "Service classes" allow reading and writing the data.

Records, image rasters and bintable columns are implemented as light structures to abstract from CFitsIO raw pointers:

- Record is made of a name, value, unit and comment;
- Column stores metadata (name, unit, width) and values;
- Raster represents a _n_-dimensional array with constant-time pixel access.

Columns and rasters each have variants, depending on who owns the data and on the data container type.
Check out the \ref data-classes documentation for more details, or the API documentation for even more details.

Service classes are organized according to the Fits format:

- MefFile, the root object, provides file-level services (open, close, access HDUs);
- RecordHdu only handles records;
- BintableHdu and ImageHdy, respectively the bintable and image HDU reader-writers, additionally provide access to the raster and columns.

To make it simple, the end-user API consists of the Euclid::FitsIO namespace.

For a gentle introduction to the library, head to this page: \ref handlers.

Last but not least, we've implemented and documented a \ref tuto.

To find more example codes, check the EL_FitsIO_Examples and EL_FitsIO_Validation modules (see below).


\section types A word on types


As shown in the \ref type_map, handling types right with CFitsIO can be very cumbersome.
EL_FitsIO aims at carrying the boilerplate internally, so that the user doesn't need to know the underlying architecture or CFitsIO implementation.
Template functions and methods are provided to simply let the user set the desired type.

As for the type of sizes and indices, there is no way to make everybody happy:

- C uses signed integers;
- The C++ standard library uses unsigned integers;
- CFitsIO uses signed integers with varying type (e.g. `int` for column count and `long` or `LONGLONG` for row count).

Following the <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Res-subscripts">C++ Core Guidelines</a>,
we've opted for signed integers, and precisely for `long`'s, in order to distinguish from integer data values which are generally `int`'s.
To reduce the noise, we did not create a custom type like "index", "length" or "size".

*/

}
}
